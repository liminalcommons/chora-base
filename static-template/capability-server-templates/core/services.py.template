"""{{ capability_name }} - Core Business Logic Services (SAP-042)

This module contains interface-agnostic business logic that implements
the core capabilities. Services orchestrate domain models and handle
business rules, validation, and state transitions.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Dict, List, Optional
from uuid import UUID

from .exceptions import (
    {{ capability_name_pascal }}Error,
    {{ capability_name_pascal }}NotFoundError,
    {{ capability_name_pascal }}ValidationError,
)
from .models import (
    {{ capability_name_pascal }}Entity,
    {{ capability_name_pascal }}Filter,
    {{ capability_name_pascal }}ListResponse,
    {{ capability_name_pascal }}Request,
    {{ capability_name_pascal }}Response,
    {{ capability_name_pascal }}Status,
)


# ============================================================================
# Abstract Base Service
# ============================================================================


class {{ capability_name_pascal }}ServiceBase(ABC):
    """Abstract base class for {{ capability_name }} services.

    Defines the contract for all service implementations. Concrete
    implementations can use different storage backends (in-memory,
    database, external API, etc.).
    """

    @abstractmethod
    async def create(
        self,
        request: {{ capability_name_pascal }}Request
    ) -> {{ capability_name_pascal }}Response:
        """Create a new {{ capability_name_lower }} entity.

        Args:
            request: Request containing entity data

        Returns:
            Response containing created entity

        Raises:
            {{ capability_name_pascal }}ValidationError: If validation fails
            {{ capability_name_pascal }}Error: If creation fails
        """
        pass

    @abstractmethod
    async def get(self, entity_id: UUID) -> {{ capability_name_pascal }}Entity:
        """Retrieve a {{ capability_name_lower }} entity by ID.

        Args:
            entity_id: Unique identifier

        Returns:
            The entity

        Raises:
            {{ capability_name_pascal }}NotFoundError: If entity not found
        """
        pass

    @abstractmethod
    async def list(
        self,
        filters: Optional[{{ capability_name_pascal }}Filter] = None
    ) -> {{ capability_name_pascal }}ListResponse:
        """List {{ capability_name_lower }} entities with optional filtering.

        Args:
            filters: Optional filter criteria

        Returns:
            Response containing list of entities and pagination metadata
        """
        pass

    @abstractmethod
    async def update(
        self,
        entity_id: UUID,
        request: {{ capability_name_pascal }}Request
    ) -> {{ capability_name_pascal }}Response:
        """Update an existing {{ capability_name_lower }} entity.

        Args:
            entity_id: Entity to update
            request: Updated data

        Returns:
            Response containing updated entity

        Raises:
            {{ capability_name_pascal }}NotFoundError: If entity not found
            {{ capability_name_pascal }}ValidationError: If validation fails
        """
        pass

    @abstractmethod
    async def delete(self, entity_id: UUID) -> None:
        """Delete a {{ capability_name_lower }} entity.

        Args:
            entity_id: Entity to delete

        Raises:
            {{ capability_name_pascal }}NotFoundError: If entity not found
        """
        pass

    @abstractmethod
    async def update_status(
        self,
        entity_id: UUID,
        new_status: {{ capability_name_pascal }}Status
    ) -> {{ capability_name_pascal }}Response:
        """Update entity status.

        Args:
            entity_id: Entity to update
            new_status: New status value

        Returns:
            Response containing updated entity

        Raises:
            {{ capability_name_pascal }}NotFoundError: If entity not found
            {{ capability_name_pascal }}ValidationError: If status transition invalid
        """
        pass


# ============================================================================
# In-Memory Service Implementation (Example)
# ============================================================================


class {{ capability_name_pascal }}Service({{ capability_name_pascal }}ServiceBase):
    """In-memory implementation of {{ capability_name }} service.

    This is a reference implementation suitable for development, testing,
    and lightweight production use. For production with persistence,
    implement a service backed by a database or external storage.
    """

    def __init__(self):
        """Initialize service with in-memory storage."""
        self._storage: Dict[UUID, {{ capability_name_pascal }}Entity] = {}

    async def create(
        self,
        request: {{ capability_name_pascal }}Request
    ) -> {{ capability_name_pascal }}Response:
        """Create a new entity."""
        try:
            # Create entity from request
            entity = {{ capability_name_pascal }}Entity(
                name=request.name,
                description=request.description,
                metadata=request.metadata,
                status={{ capability_name_pascal }}Status.PENDING,
            )

            # Store entity
            self._storage[entity.id] = entity

            return {{ capability_name_pascal }}Response(
                entity=entity,
                message=f"{{ capability_name }} '{entity.name}' created successfully",
                success=True
            )

        except Exception as e:
            raise {{ capability_name_pascal }}Error(
                f"Failed to create {{ capability_name_lower }}: {str(e)}"
            ) from e

    async def get(self, entity_id: UUID) -> {{ capability_name_pascal }}Entity:
        """Retrieve entity by ID."""
        entity = self._storage.get(entity_id)
        if not entity:
            raise {{ capability_name_pascal }}NotFoundError(
                f"{{ capability_name }} with ID '{entity_id}' not found"
            )
        return entity

    async def list(
        self,
        filters: Optional[{{ capability_name_pascal }}Filter] = None
    ) -> {{ capability_name_pascal }}ListResponse:
        """List entities with optional filtering."""
        filters = filters or {{ capability_name_pascal }}Filter()

        # Start with all entities
        entities = list(self._storage.values())

        # Apply status filter
        if filters.status is not None:
            entities = [e for e in entities if e.status == filters.status]

        # Apply name filter
        if filters.name_contains:
            search_term = filters.name_contains.lower()
            entities = [
                e for e in entities
                if search_term in e.name.lower()
            ]

        # Apply date filters
        if filters.created_after:
            entities = [
                e for e in entities
                if e.created_at >= filters.created_after
            ]

        if filters.created_before:
            entities = [
                e for e in entities
                if e.created_at <= filters.created_before
            ]

        # Sort by created_at descending (newest first)
        entities.sort(key=lambda e: e.created_at, reverse=True)

        # Get total before pagination
        total = len(entities)

        # Apply pagination
        start = filters.offset
        end = start + filters.limit
        entities = entities[start:end]

        return {{ capability_name_pascal }}ListResponse(
            entities=entities,
            total=total,
            offset=filters.offset,
            limit=filters.limit
        )

    async def update(
        self,
        entity_id: UUID,
        request: {{ capability_name_pascal }}Request
    ) -> {{ capability_name_pascal }}Response:
        """Update existing entity."""
        # Ensure entity exists
        entity = await self.get(entity_id)

        # Update fields
        entity.name = request.name
        entity.description = request.description
        entity.metadata = request.metadata
        entity.updated_at = datetime.utcnow()

        # Store updated entity
        self._storage[entity_id] = entity

        return {{ capability_name_pascal }}Response(
            entity=entity,
            message=f"{{ capability_name }} '{entity.name}' updated successfully",
            success=True
        )

    async def delete(self, entity_id: UUID) -> None:
        """Delete entity."""
        # Ensure entity exists
        await self.get(entity_id)

        # Remove from storage
        del self._storage[entity_id]

    async def update_status(
        self,
        entity_id: UUID,
        new_status: {{ capability_name_pascal }}Status
    ) -> {{ capability_name_pascal }}Response:
        """Update entity status."""
        # Ensure entity exists
        entity = await self.get(entity_id)

        # Validate status transition (example business rule)
        if not self._is_valid_status_transition(entity.status, new_status):
            raise {{ capability_name_pascal }}ValidationError(
                f"Invalid status transition from {entity.status} to {new_status}"
            )

        # Update status
        old_status = entity.status
        entity.status = new_status
        entity.updated_at = datetime.utcnow()

        # Store updated entity
        self._storage[entity.id] = entity

        return {{ capability_name_pascal }}Response(
            entity=entity,
            message=f"Status updated from {old_status} to {new_status}",
            success=True
        )

    def _is_valid_status_transition(
        self,
        current: {{ capability_name_pascal }}Status,
        new: {{ capability_name_pascal }}Status
    ) -> bool:
        """Validate status transition.

        Example business rules:
        - PENDING → ACTIVE, CANCELLED
        - ACTIVE → COMPLETED, FAILED, CANCELLED
        - COMPLETED/FAILED/CANCELLED → No transitions (terminal states)
        """
        valid_transitions = {
            {{ capability_name_pascal }}Status.PENDING: {
                {{ capability_name_pascal }}Status.ACTIVE,
                {{ capability_name_pascal }}Status.CANCELLED,
            },
            {{ capability_name_pascal }}Status.ACTIVE: {
                {{ capability_name_pascal }}Status.COMPLETED,
                {{ capability_name_pascal }}Status.FAILED,
                {{ capability_name_pascal }}Status.CANCELLED,
            },
            {{ capability_name_pascal }}Status.COMPLETED: set(),
            {{ capability_name_pascal }}Status.FAILED: set(),
            {{ capability_name_pascal }}Status.CANCELLED: set(),
        }

        return new in valid_transitions.get(current, set())

    async def health_check(self) -> Dict[str, any]:
        """Check service health.

        Returns:
            Health status information
        """
        return {
            "status": "healthy",
            "entity_count": len(self._storage),
            "timestamp": datetime.utcnow().isoformat()
        }


# ============================================================================
# Service Factory (Dependency Injection)
# ============================================================================


def create_{{ capability_name_lower }}_service() -> {{ capability_name_pascal }}ServiceBase:
    """Create and configure a {{ capability_name }} service instance.

    This factory function enables dependency injection and makes it easy
    to swap implementations (e.g., in-memory for testing, database for
    production).

    Returns:
        Configured service instance
    """
    # For now, return in-memory implementation
    # In production, you might read from config to decide which implementation
    return {{ capability_name_pascal }}Service()
