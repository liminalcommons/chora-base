"""{{ capability_name }} - Core Domain Models (SAP-042)

This module contains interface-agnostic Pydantic models that represent
the core business domain. These models are shared across all interfaces
(CLI, REST, MCP) following the core/interface separation pattern.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, field_validator


# ============================================================================
# Base Models
# ============================================================================


class {{ capability_name_pascal }}BaseModel(BaseModel):
    """Base model for all {{ capability_name }} domain models.

    Provides common fields and configuration for domain entities.
    """

    model_config = {
        "json_schema_extra": {
            "examples": []
        },
        "populate_by_name": True,
        "use_enum_values": True,
    }


class TimestampedModel({{ capability_name_pascal }}BaseModel):
    """Base model with automatic timestamp tracking."""

    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when entity was created"
    )
    updated_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when entity was last updated"
    )


# ============================================================================
# Enums
# ============================================================================


class {{ capability_name_pascal }}Status(str, Enum):
    """Status values for {{ capability_name }} entities."""

    PENDING = "pending"
    ACTIVE = "active"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


# ============================================================================
# Domain Models
# ============================================================================


class {{ capability_name_pascal }}Request({{ capability_name_pascal }}BaseModel):
    """Request model for {{ capability_name }} operations.

    This model represents input data for creating or updating
    {{ capability_name }} entities.
    """

    name: str = Field(
        ...,
        min_length=1,
        max_length=200,
        description="Name of the {{ capability_name_snake }} entity",
        examples=["Example {{ capability_name }}"]
    )

    description: Optional[str] = Field(
        None,
        max_length=2000,
        description="Optional description",
        examples=["A detailed description of this {{ capability_name_snake }}"]
    )

    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional metadata as key-value pairs"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate name field."""
        if not v.strip():
            raise ValueError("Name cannot be empty or whitespace")
        return v.strip()


class {{ capability_name_pascal }}Entity(TimestampedModel):
    """Core domain entity for {{ capability_name }}.

    This model represents a {{ capability_name_snake }} entity with full
    lifecycle tracking (id, timestamps, status).
    """

    id: UUID = Field(
        default_factory=uuid4,
        description="Unique identifier for this entity"
    )

    name: str = Field(
        ...,
        min_length=1,
        max_length=200,
        description="Name of the entity"
    )

    description: Optional[str] = Field(
        None,
        max_length=2000,
        description="Optional description"
    )

    status: {{ capability_name_pascal }}Status = Field(
        default={{ capability_name_pascal }}Status.PENDING,
        description="Current status of the entity"
    )

    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional metadata"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate name field."""
        if not v.strip():
            raise ValueError("Name cannot be empty or whitespace")
        return v.strip()

    def to_dict(self) -> Dict[str, Any]:
        """Convert entity to dictionary representation.

        Returns:
            Dictionary with all entity fields, with datetime objects
            converted to ISO format strings.
        """
        data = self.model_dump()
        # Convert datetime objects to ISO format strings
        data["created_at"] = self.created_at.isoformat()
        data["updated_at"] = self.updated_at.isoformat()
        # Convert UUID to string
        data["id"] = str(self.id)
        return data


class {{ capability_name_pascal }}Response({{ capability_name_pascal }}BaseModel):
    """Response model for {{ capability_name }} operations.

    This model represents output data returned from operations,
    typically containing the entity and optional metadata.
    """

    entity: {{ capability_name_pascal }}Entity = Field(
        ...,
        description="The {{ capability_name_snake }} entity"
    )

    message: Optional[str] = Field(
        None,
        description="Optional response message"
    )

    success: bool = Field(
        True,
        description="Whether the operation succeeded"
    )


class {{ capability_name_pascal }}ListResponse({{ capability_name_pascal }}BaseModel):
    """Response model for listing {{ capability_name }} entities.

    Supports pagination and filtering.
    """

    entities: List[{{ capability_name_pascal }}Entity] = Field(
        default_factory=list,
        description="List of {{ capability_name_snake }} entities"
    )

    total: int = Field(
        0,
        ge=0,
        description="Total number of entities matching filters"
    )

    offset: int = Field(
        0,
        ge=0,
        description="Offset used for pagination"
    )

    limit: int = Field(
        100,
        ge=1,
        le=1000,
        description="Maximum number of entities returned"
    )


# ============================================================================
# Filter Models
# ============================================================================


class {{ capability_name_pascal }}Filter({{ capability_name_pascal }}BaseModel):
    """Filter criteria for querying {{ capability_name }} entities."""

    status: Optional[{{ capability_name_pascal }}Status] = Field(
        None,
        description="Filter by status"
    )

    name_contains: Optional[str] = Field(
        None,
        description="Filter by name containing this string (case-insensitive)"
    )

    created_after: Optional[datetime] = Field(
        None,
        description="Filter entities created after this timestamp"
    )

    created_before: Optional[datetime] = Field(
        None,
        description="Filter entities created before this timestamp"
    )

    offset: int = Field(
        0,
        ge=0,
        description="Pagination offset"
    )

    limit: int = Field(
        100,
        ge=1,
        le=1000,
        description="Maximum number of results"
    )


# ============================================================================
# Example Usage (for documentation/testing)
# ============================================================================

if __name__ == "__main__":
    # Example: Create a request
    request = {{ capability_name_pascal }}Request(
        name="Example {{ capability_name }}",
        description="This is an example entity",
        metadata={"key": "value"}
    )
    print(f"Request: {request.model_dump_json(indent=2)}")

    # Example: Create an entity
    entity = {{ capability_name_pascal }}Entity(
        name=request.name,
        description=request.description,
        metadata=request.metadata,
        status={{ capability_name_pascal }}Status.ACTIVE
    )
    print(f"\nEntity: {entity.model_dump_json(indent=2)}")

    # Example: Create a response
    response = {{ capability_name_pascal }}Response(
        entity=entity,
        message="Entity created successfully",
        success=True
    )
    print(f"\nResponse: {response.model_dump_json(indent=2)}")
