# {{ capability_name }} - Architecture

**Version**: 0.1.0
**Generated by**: chora-base SAP-047 (Capability Server Template)
**Last Updated**: {{ current_date }}

---

## Overview

This document provides a deep dive into the architecture, design patterns, and implementation details of the {{ capability_name }} capability server.

**Key Principles**:
- ðŸŽ¯ **Core/Interface Separation** (SAP-042) - Business logic independent of interfaces
- ðŸ”Œ **Multi-Interface Support** (SAP-043) - CLI, REST{% if enable_mcp %}, MCP{% endif %} from single core
- ðŸ“¦ **Dependency Injection** - Testable, swappable components
- ðŸ›¡ï¸ **Type Safety** - Pydantic models with full type hints
- âœ… **Test Coverage** - 85%+ coverage target

---

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Interfaces Layer                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  {% if enable_mcp %}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”{% endif %}                       â”‚
â”‚  â”‚   CLI    â”‚  â”‚   REST   â”‚  {% if enable_mcp %}â”‚   MCP    â”‚{% endif %}                       â”‚
â”‚  â”‚ (Click)  â”‚  â”‚(FastAPI) â”‚  {% if enable_mcp %}â”‚(FastMCP) â”‚{% endif %}                       â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  {% if enable_mcp %}â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜{% endif %}                       â”‚
â”‚       â”‚             â”‚             {% if enable_mcp %}â”‚{% endif %}                             â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚                     â”‚                                           â”‚
â”‚                     â–¼                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚                 Core Layer                       â”‚          â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚          â”‚
â”‚  â”‚  â”‚  Models  â”‚  â”‚ Services â”‚  â”‚Exceptionsâ”‚      â”‚          â”‚
â”‚  â”‚  â”‚(Pydantic)â”‚  â”‚ (Logic)  â”‚  â”‚(Errors)  â”‚      â”‚          â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚{% if enable_registry or enable_bootstrap or enable_composition %}                     â”‚                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚           Infrastructure Layer                   â”‚          â”‚
â”‚  â”‚{% if enable_registry %}  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”{% endif %}{% if enable_bootstrap %}  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”{% endif %}{% if enable_composition %}  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”{% endif %}      â”‚          â”‚
â”‚  â”‚{% if enable_registry %}  â”‚ Registry â”‚{% endif %}{% if enable_bootstrap %}  â”‚Bootstrap â”‚{% endif %}{% if enable_composition %}  â”‚Compositionâ”‚{% endif %}     â”‚          â”‚
â”‚  â”‚{% if enable_registry %}  â”‚(SAP-044) â”‚{% endif %}{% if enable_bootstrap %}  â”‚(SAP-045) â”‚{% endif %}{% if enable_composition %}  â”‚(SAP-046) â”‚{% endif %}      â”‚          â”‚
â”‚  â”‚{% if enable_registry %}  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜{% endif %}{% if enable_bootstrap %}  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜{% endif %}{% if enable_composition %}  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜{% endif %}      â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
{% endif %}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Core Layer

**Purpose**: Interface-agnostic business logic

**Location**: `{{ package_name }}/core/`

### Models (`models.py`)

**Pydantic Models** for domain entities with validation:

**Base Models**:
```python
class BaseModel(pydantic.BaseModel):
    """Shared configuration for all models."""

    model_config = ConfigDict(
        validate_assignment=True,
        str_strip_whitespace=True,
        use_enum_values=False
    )

class TimestampedModel(BaseModel):
    """Model with automatic timestamps."""

    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

**Domain Entity**:
```python
class {{ capability_name_pascal }}Entity(TimestampedModel):
    """Core domain entity."""

    id: UUID = Field(default_factory=uuid4)
    name: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=2000)
    status: {{ capability_name_pascal }}Status = Field(default={{ capability_name_pascal }}Status.PENDING)
    metadata: Dict[str, Any] = Field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary with ISO timestamps."""
        return {
            **self.model_dump(),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }
```

**Request/Response Models**:
- `{{ capability_name_pascal }}Request` - Entity creation/update
- `{{ capability_name_pascal }}Response` - Operation results
- `{{ capability_name_pascal }}Filter` - List filtering
- `{{ capability_name_pascal }}ListResponse` - Paginated lists

**Design Decisions**:
- UUID for globally unique IDs
- ISO 8601 timestamps (UTC)
- Pydantic validation for type safety
- Metadata as flexible key-value store

---

### Services (`services.py`)

**Abstract Service Base**:
```python
class {{ capability_name_pascal }}ServiceBase(ABC):
    """Abstract base for swappable implementations."""

    @abstractmethod
    async def create(self, request: {{ capability_name_pascal }}Request) -> {{ capability_name_pascal }}Response:
        """Create entity."""
        pass

    @abstractmethod
    async def get(self, entity_id: UUID) -> {{ capability_name_pascal }}Entity:
        """Get entity by ID."""
        pass

    # ... other CRUD operations
```

**In-Memory Implementation**:
```python
class {{ capability_name_pascal }}Service({{ capability_name_pascal }}ServiceBase):
    """In-memory implementation (development/lightweight production)."""

    def __init__(self):
        self._storage: Dict[UUID, {{ capability_name_pascal }}Entity] = {}

    async def create(self, request: {{ capability_name_pascal }}Request) -> {{ capability_name_pascal }}Response:
        entity = {{ capability_name_pascal }}Entity(
            name=request.name,
            description=request.description,
            metadata=request.metadata
        )
        self._storage[entity.id] = entity
        return {{ capability_name_pascal }}Response(
            success=True,
            message="Entity created successfully",
            entity=entity
        )
```

**Factory Function**:
```python
def create_{{ capability_name_lower }}_service() -> {{ capability_name_pascal }}ServiceBase:
    """Factory for dependency injection."""
    return {{ capability_name_pascal }}Service()
```

**Design Decisions**:
- Abstract base for multiple implementations (in-memory, database, etc.)
- Factory pattern for dependency injection
- Async/await throughout for scalability
- Status transition validation
- In-memory storage for simplicity (swap with database as needed)

---

### Exceptions (`exceptions.py`)

**Exception Hierarchy**:
```
{{ capability_name_pascal }}Error (Base)
â”œâ”€â”€ {{ capability_name_pascal }}ValidationError (400)
â”œâ”€â”€ {{ capability_name_pascal }}NotFoundError (404)
â”œâ”€â”€ {{ capability_name_pascal }}ConflictError (409)
â”œâ”€â”€ {{ capability_name_pascal }}PermissionError (403)
â”œâ”€â”€ {{ capability_name_pascal }}RateLimitError (429)
â”œâ”€â”€ {{ capability_name_pascal }}TimeoutError (504)
â””â”€â”€ {{ capability_name_pascal }}ServiceError (500)
```

**Base Exception**:
```python
class {{ capability_name_pascal }}Error(Exception):
    """Base exception with serialization."""

    def __init__(
        self,
        message: str,
        code: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None
    ):
        self.message = message
        self.code = code or self.__class__.__name__.upper()
        self.details = details or {}
        super().__init__(self.message)

    def to_dict(self) -> Dict[str, Any]:
        """Serialize for API responses."""
        return {
            "error": self.code,
            "message": self.message,
            "details": self.details
        }
```

**Design Decisions**:
- Machine-readable error codes
- Serializable for JSON APIs
- HTTP status code mapping
- Detailed error context in `details`

---

## Interface Layer

**Purpose**: Adapt core logic to specific interfaces

**Location**: `{{ package_name }}/interfaces/`

### CLI Interface (`interfaces/cli/`)

**Framework**: Click

**Structure**:
- `__init__.py` - Click app setup, global options
- `commands.py` - Command definitions (create, get, list, update, delete, status, health)
- `formatters.py` - Output formatting (JSON, table, YAML)

**Key Pattern - Async Command Wrapper**:
```python
def async_command(f):
    """Wrapper to run async commands in Click."""
    @wraps(f)
    def wrapper(*args, **kwargs):
        return asyncio.run(f(*args, **kwargs))
    return wrapper

@click.command()
@async_command
async def create_command(ctx, name, description):
    service = ctx.obj["service"]
    request = {{ capability_name_pascal }}Request(name=name, description=description)
    response = await service.create(request)
    print_entity(response.entity.to_dict(), ctx.obj["format"])
```

**Design Decisions**:
- Click for declarative CLI
- Async wrapper for core service calls
- Multiple output formats (JSON, table, YAML)
- Color-coded messages for UX
- Context object for shared state

---

### REST Interface (`interfaces/rest/`)

**Framework**: FastAPI

**Structure**:
- `__init__.py` - FastAPI app, CORS, middleware
- `routes.py` - API endpoints (9 endpoints)
- `models.py` - API-specific request/response models
- `middleware.py` - Exception-to-HTTP mapping

**Key Pattern - Exception Middleware**:
```python
async def error_handler_middleware(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except {{ capability_name_pascal }}ValidationError as e:
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content=e.to_dict()
        )
    except {{ capability_name_pascal }}NotFoundError as e:
        return JSONResponse(
            status_code=status.HTTP_404_NOT_FOUND,
            content=e.to_dict()
        )
    # ... other exceptions
```

**Design Decisions**:
- FastAPI for automatic OpenAPI docs
- Exception middleware for consistent error handling
- CORS enabled for frontend integration
- Request duration tracking
- Dependency injection for service

---

{% if enable_mcp %}### MCP Interface (`interfaces/mcp/`)

**Framework**: FastMCP

**Structure**:
- `__init__.py` - MCP server setup
- `tools.py` - 7 MCP tools (create, get, list, update, delete, update_status, health)
- `resources.py` - 4 documentation resources

**Key Pattern - Tool with Error Handling**:
```python
@mcp.tool(name=make_tool_name("create"))
async def create_entity(
    name: str,
    description: Optional[str] = None,
    metadata: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """Create entity via MCP."""
    try:
        service = create_{{ capability_name_lower }}_service()
        request = {{ capability_name_pascal }}Request(
            name=name,
            description=description,
            metadata=metadata or {}
        )
        response = await service.create(request)
        return {
            "success": True,
            "message": response.message,
            "entity": response.entity.to_dict()
        }
    except {{ capability_name_pascal }}Error as e:
        return {
            "success": False,
            "error": e.code,
            "message": e.message,
            "details": e.details
        }
```

**Design Decisions**:
- Namespaced tool names (`{{ namespace }}:create`)
- Structured error responses (no exceptions to AI)
- UUID/status validation before core calls
- Documentation resources for AI context
- Read-only resources (markdown docs, templates)

---

{% endif %}{% if enable_registry or enable_bootstrap or enable_composition %}## Infrastructure Layer

**Purpose**: Optional production patterns

**Location**: `{{ package_name }}/infrastructure/`

{% if enable_registry %}### Service Registry (SAP-044)

**Purpose**: Service discovery and capability registration

**Location**: `infrastructure/registry/`

**Key Components**:
```python
class ServiceRegistry:
    """In-memory service registry."""

    def __init__(self, heartbeat_timeout_seconds: int = 30):
        self._services: Dict[UUID, ServiceRegistration] = {}
        self._heartbeat_timeout = timedelta(seconds=heartbeat_timeout_seconds)

    def register(
        self,
        service_name: str,
        service_type: str,
        version: str,
        capabilities: List[str],
        interfaces: List[str],
        endpoints: Dict[str, str],
        metadata: Optional[Dict[str, Any]] = None
    ) -> ServiceRegistration:
        """Register service."""
        # ...

    def discover_capability(self, capability: str) -> List[ServiceRegistration]:
        """Find services by capability."""
        return self.list_services(capability=capability, status=ServiceStatus.HEALTHY)
```

**Use Cases**:
- Microservice discovery
- Load balancing
- Health monitoring
- Capability-based routing

{% endif %}{% if enable_bootstrap %}### Bootstrap Orchestration (SAP-045)

**Purpose**: Dependency-ordered component startup

**Location**: `infrastructure/bootstrap/`

**Key Components**:
```python
class Bootstrap:
    """Dependency-ordered startup orchestrator."""

    async def start(self) -> BootstrapResult:
        """Start components in dependency order."""
        startup_order = self._resolve_dependencies()  # Topological sort

        for component_name in startup_order:
            component = self._components[component_name]
            try:
                await self._start_component(component)
                self._started_components.append(component_name)
            except Exception as e:
                if component.critical:
                    await self._rollback()  # Stop all started components
                    return BootstrapResult(success=False, ...)

        return BootstrapResult(success=True, phase=BootstrapPhase.READY)
```

**Algorithms**:
- **Topological Sort** (Kahn's algorithm) for dependency resolution
- **Rollback** in reverse order on failure
- **Circular Dependency** detection

**Use Cases**:
- Multi-component applications
- Database migrations before API server
- Cache warming before accepting requests

{% endif %}{% if enable_composition %}### Composition Patterns (SAP-046)

**Purpose**: Distributed system reliability patterns

**Location**: `infrastructure/composition/`

#### Circuit Breaker

**Pattern**: Prevent cascading failures

```python
class CircuitBreaker:
    """Circuit breaker with 3 states: CLOSED, OPEN, HALF_OPEN."""

    async def call(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function through circuit breaker."""
        if self._state == CircuitState.OPEN:
            raise CircuitBreakerOpen("Circuit is open")

        try:
            result = await asyncio.wait_for(func(*args, **kwargs), timeout=self.request_timeout)
            self._on_success()  # Reset failure count or close circuit
            return result
        except Exception as e:
            self._on_failure()  # Increment failures, maybe open circuit
            raise
```

**State Transitions**:
```
CLOSED --[failure_threshold]--> OPEN
OPEN --[recovery_timeout]--> HALF_OPEN
HALF_OPEN --[success_threshold]--> CLOSED
HALF_OPEN --[failure]--> OPEN
```

#### Event Bus

**Pattern**: Event-driven communication (pub-sub)

```python
class EventBus:
    """In-memory event bus."""

    async def publish(
        self,
        event_type: str,
        source: str,
        data: Optional[Dict[str, Any]] = None
    ) -> Event:
        """Publish event to subscribers."""
        event = Event(event_type=event_type, source=source, data=data or {})
        self._add_to_history(event)
        await self._notify_handlers(event)  # Concurrent execution
        return event

    def subscribe(self, event_type: str, handler: EventHandler):
        """Subscribe to event type."""
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
```

**Features**:
- Multiple subscribers per event type
- Concurrent handler execution
- Error isolation (one handler failure doesn't affect others)
- Event history with filtering

#### Saga Pattern

**Pattern**: Distributed transactions with compensation

```python
class Saga:
    """Saga orchestrator."""

    def add_step(
        self,
        name: str,
        action: Callable,
        compensation: Optional[Callable] = None,
        timeout_seconds: int = 30,
        retries: int = 0
    ):
        """Add saga step with forward action and compensation."""
        step = SagaStep(name=name, action=action, compensation=compensation, ...)
        self._steps.append(step)

    async def execute(self, context: Optional[SagaContext] = None) -> Dict[str, Any]:
        """Execute saga, compensate on failure."""
        for step in self._steps:
            try:
                step_result = await self._execute_step(step, context)
                self._completed_steps.append(step.name)
            except Exception as e:
                await self._compensate(context)  # Reverse order compensation
                return {"status": "compensated", "error": str(e)}

        return {"status": "completed", "completed_steps": self._completed_steps}
```

**Compensation Flow**:
```
Forward:      Step1 â†’ Step2 â†’ Step3 â†’ [FAILURE]
Compensation:        â† Undo2 â† Undo1
```

{% endif %}---

{% endif %}## Testing Strategy

**Coverage Target**: 85%+

**Test Structure**:
```
tests/
â”œâ”€â”€ core/                    # Core logic tests
â”‚   â”œâ”€â”€ test_models.py       # Model validation, serialization
â”‚   â”œâ”€â”€ test_services.py     # CRUD operations, business logic
â”‚   â””â”€â”€ test_exceptions.py   # Exception hierarchy, serialization
â”œâ”€â”€ interfaces/              # Interface tests
â”‚   â”œâ”€â”€ test_cli.py          # CLI commands, output formats
â”‚   â”œâ”€â”€ test_rest.py         # REST endpoints, HTTP status codes
{% if enable_mcp %}â”‚   â””â”€â”€ test_mcp.py          # MCP tools, resources
{% endif %}{% if enable_registry or enable_bootstrap or enable_composition %}â””â”€â”€ infrastructure/         # Infrastructure tests
{% if enable_registry %}    â”œâ”€â”€ test_registry.py     # Service discovery, health monitoring
{% endif %}{% if enable_bootstrap %}    â”œâ”€â”€ test_bootstrap.py    # Dependency resolution, rollback
{% endif %}{% if enable_composition %}    â”œâ”€â”€ test_circuit_breaker.py  # State transitions
    â”œâ”€â”€ test_event_bus.py     # Pub-sub, event history
    â””â”€â”€ test_saga.py          # Compensation, retries
{% endif %}{% endif %}```

**Testing Frameworks**:
- `pytest` - Test runner
- `pytest-asyncio` - Async test support
- `pytest-cov` - Coverage measurement
- `Click.testing.CliRunner` - CLI testing
- `FastAPI.testclient.TestClient` - REST API testing

**Key Patterns**:
```python
# Async test
@pytest.mark.asyncio
async def test_create_entity():
    service = create_{{ capability_name_lower }}_service()
    request = {{ capability_name_pascal }}Request(name="Test")
    response = await service.create(request)
    assert response.success is True

# CLI test
def test_create_command(runner):
    result = runner.invoke(cli, ["create", "Test Entity"])
    assert result.exit_code == 0
    assert "created successfully" in result.output.lower()

# REST API test
def test_create_endpoint(client):
    response = client.post(
        "/api/v1/{{ namespace }}/entities",
        json={"name": "Test Entity"}
    )
    assert response.status_code == 201
    assert response.json()["success"] is True
```

---

## Design Patterns

### 1. Core/Interface Separation (SAP-042)

**Problem**: Tight coupling between business logic and interfaces

**Solution**: Core layer with interface adapters

**Benefits**:
- Core logic testable without interfaces
- Add new interfaces without changing core
- Swap storage backends without touching interfaces

---

### 2. Dependency Injection

**Problem**: Hard-coded dependencies make testing difficult

**Solution**: Factory functions for service creation

```python
# Factory
def create_{{ capability_name_lower }}_service() -> {{ capability_name_pascal }}ServiceBase:
    return {{ capability_name_pascal }}Service()

# Usage in interface
service = create_{{ capability_name_lower }}_service()

# Testing with mock
def test_with_mock():
    service = Mock(spec={{ capability_name_pascal }}ServiceBase)
    # ...
```

---

### 3. Abstract Base Class

**Problem**: Want multiple implementations (in-memory, database, etc.)

**Solution**: Abstract base class with concrete implementations

**Benefits**:
- Swap implementations without changing interfaces
- Type safety via ABC
- Clear contract for implementations

---

### 4. Async/Await Throughout

**Problem**: Blocking I/O limits scalability

**Solution**: Async/await for all I/O operations

**Benefits**:
- Scalable to high concurrency
- Non-blocking database/API calls
- FastAPI async support

---

### 5. Factory Pattern

**Problem**: Service instantiation logic scattered

**Solution**: Factory functions centralize creation

**Benefits**:
- Single point of configuration
- Easy to swap implementations
- Testability via dependency injection

---

## Configuration

**Location**: `{{ package_name }}/config/settings.py`

**Environment Variables**:
```python
class Settings(BaseSettings):
    """Application settings from environment."""

    log_level: str = Field(default="INFO", env="{{ package_name.upper() }}_LOG_LEVEL")
    port: int = Field(default=8000, env="{{ package_name.upper() }}_PORT")
    {% if enable_registry %}registry_url: Optional[str] = Field(None, env="{{ package_name.upper() }}_REGISTRY_URL")
    {% endif %}
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8"
    )
```

---

## Deployment

### Development

```bash
# CLI
{{ package_name }} create "Task"

# REST API
uvicorn {{ package_name }}.interfaces.rest:app --reload --port 8000

{% if enable_mcp %}# MCP Server
{{ package_name }}-mcp
{% endif %}```

### Production

**Docker**:
```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY . .

RUN pip install --no-cache-dir .

EXPOSE 8000
CMD ["gunicorn", "{{ package_name }}.interfaces.rest:app", \
     "-w", "4", "-k", "uvicorn.workers.UvicornWorker", \
     "--bind", "0.0.0.0:8000"]
```

**Docker Compose** (with database):
```yaml
services:
  {{ package_name }}:
    build: .
    ports:
      - "8000:8000"
    environment:
      - {{ package_name.upper() }}_LOG_LEVEL=INFO
    depends_on:
      - postgres

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB={{ package_name }}
      - POSTGRES_PASSWORD=secret
```

---

## Performance Considerations

**In-Memory Storage**:
- âœ… Fast for development/testing
- âœ… Simple deployment (no database)
- âš ï¸ Not persistent across restarts
- âš ï¸ Limited scalability (single process)

**Scaling Strategies**:
1. **Horizontal**: Add database (PostgreSQL, MongoDB), share state
2. **Vertical**: Use gunicorn with multiple workers
3. **Caching**: Add Redis for hot data
{% if enable_registry %}4. **Service Mesh**: Use registry for multi-instance coordination
{% endif %}

---

## Security Considerations

**Current** (development):
- No authentication
- No authorization
- CORS allows all origins
- No rate limiting

**Production Recommendations**:
1. **Authentication**: Add JWT, API keys, or OAuth
2. **Authorization**: Role-based access control (RBAC)
3. **CORS**: Restrict to specific origins
4. **Rate Limiting**: Prevent abuse
5. **HTTPS**: TLS encryption in transit
6. **Input Validation**: Already implemented via Pydantic
7. **SQL Injection**: Not applicable (in-memory storage)

---

## Migration Paths

### From In-Memory to Database

**Step 1**: Implement new service class
```python
class {{ capability_name_pascal }}DatabaseService({{ capability_name_pascal }}ServiceBase):
    def __init__(self, db_url: str):
        self.engine = create_async_engine(db_url)

    async def create(self, request: {{ capability_name_pascal }}Request) -> {{ capability_name_pascal }}Response:
        async with self.session() as session:
            entity = {{ capability_name_pascal }}ORM(name=request.name, ...)
            session.add(entity)
            await session.commit()
            return {{ capability_name_pascal }}Response(success=True, entity=...)
```

**Step 2**: Update factory
```python
def create_{{ capability_name_lower }}_service() -> {{ capability_name_pascal }}ServiceBase:
    db_url = os.getenv("DATABASE_URL")
    if db_url:
        return {{ capability_name_pascal }}DatabaseService(db_url)
    return {{ capability_name_pascal }}Service()  # Fallback to in-memory
```

**Benefits**:
- Zero changes to interfaces
- Gradual migration
- Backward compatible

---

## Monitoring & Observability

**Logging**:
```python
import logging

logger = logging.getLogger(__name__)

async def create(self, request):
    logger.info(f"Creating entity: {request.name}")
    # ...
    logger.debug(f"Created entity with ID: {entity.id}")
```

**Metrics** (with Prometheus):
```python
from prometheus_client import Counter, Histogram

entity_create_count = Counter("entity_create_total", "Total entities created")
request_duration = Histogram("request_duration_seconds", "Request duration")

@request_duration.time()
async def create(self, request):
    entity_create_count.inc()
    # ...
```

**Tracing** (with OpenTelemetry):
```python
from opentelemetry import trace

tracer = trace.get_tracer(__name__)

async def create(self, request):
    with tracer.start_as_current_span("create_entity"):
        # ...
```

---

## Related Documentation

- **[CLI.md](CLI.md)** - CLI reference
- **[API.md](API.md)** - REST API reference
- **[AGENTS.md](AGENTS.md)** - Agent awareness guide

---

## SAP References

- **SAP-042**: [Interface Design](https://github.com/anthropics/chora-base) - Core/interface separation
- **SAP-043**: [Multi-Interface](https://github.com/anthropics/chora-base) - CLI/REST/MCP patterns
{% if enable_registry %}- **SAP-044**: [Registry](https://github.com/anthropics/chora-base) - Service discovery
{% endif %}{% if enable_bootstrap %}- **SAP-045**: [Bootstrap](https://github.com/anthropics/chora-base) - Startup orchestration
{% endif %}{% if enable_composition %}- **SAP-046**: [Composition](https://github.com/anthropics/chora-base) - Saga, circuit breaker, events
{% endif %}- **SAP-047**: [Capability Server Template](https://github.com/anthropics/chora-base) - Template system

---

**Generated by**: chora-base SAP-047 Capability Server Template