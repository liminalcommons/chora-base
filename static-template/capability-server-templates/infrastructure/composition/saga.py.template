"""{{ capability_name }} - Saga Pattern (SAP-046)

Saga orchestration for distributed transactions with compensation.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

from datetime import datetime
from enum import Enum
from typing import Any, Callable, Dict, List, Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field


# ============================================================================
# Saga Status Enum
# ============================================================================


class SagaStatus(str, Enum):
    """Saga execution status."""

    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    COMPENSATING = "compensating"
    COMPENSATED = "compensated"
    FAILED = "failed"


# ============================================================================
# Saga Step
# ============================================================================


class SagaStep(BaseModel):
    """Single step in a saga."""

    name: str = Field(
        ...,
        description="Step name"
    )

    action: Optional[Callable] = Field(
        None,
        description="Forward action (async function)",
        exclude=True
    )

    compensation: Optional[Callable] = Field(
        None,
        description="Compensation action (async function)",
        exclude=True
    )

    timeout_seconds: int = Field(
        30,
        description="Step timeout in seconds"
    )

    retries: int = Field(
        0,
        description="Number of retries for this step"
    )

    model_config = {
        "arbitrary_types_allowed": True
    }


# ============================================================================
# Saga Execution Context
# ============================================================================


class SagaContext(BaseModel):
    """Context passed between saga steps."""

    saga_id: UUID = Field(
        default_factory=uuid4,
        description="Unique saga identifier"
    )

    data: Dict[str, Any] = Field(
        default_factory=dict,
        description="Shared data between steps"
    )

    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Saga metadata"
    )

    step_results: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Results from completed steps"
    )


# ============================================================================
# Saga Implementation
# ============================================================================


class Saga:
    """Saga orchestrator for distributed transactions.

    Executes steps in sequence. If any step fails, compensates
    all completed steps in reverse order to maintain consistency.

    Example:
        ```python
        saga = Saga()

        # Step 1: Reserve inventory
        saga.add_step(
            name="reserve_inventory",
            action=reserve_inventory_fn,
            compensation=release_inventory_fn
        )

        # Step 2: Process payment
        saga.add_step(
            name="process_payment",
            action=process_payment_fn,
            compensation=refund_payment_fn
        )

        # Step 3: Create order
        saga.add_step(
            name="create_order",
            action=create_order_fn,
            compensation=cancel_order_fn
        )

        # Execute saga
        result = await saga.execute(context)
        ```
    """

    def __init__(self):
        """Initialize saga."""
        self._steps: List[SagaStep] = []
        self._status = SagaStatus.PENDING
        self._completed_steps: List[str] = []
        self._failed_step: Optional[str] = None
        self._error: Optional[str] = None

    def add_step(
        self,
        name: str,
        action: Callable,
        compensation: Optional[Callable] = None,
        timeout_seconds: int = 30,
        retries: int = 0
    ):
        """Add a step to the saga.

        Args:
            name: Step name
            action: Forward action (async function)
            compensation: Compensation action (async function)
            timeout_seconds: Step timeout
            retries: Number of retries
        """
        step = SagaStep(
            name=name,
            action=action,
            compensation=compensation,
            timeout_seconds=timeout_seconds,
            retries=retries
        )
        self._steps.append(step)

    async def execute(self, context: Optional[SagaContext] = None) -> Dict[str, Any]:
        """Execute the saga.

        Args:
            context: Optional initial context

        Returns:
            Execution result with status and data
        """
        if not context:
            context = SagaContext()

        self._status = SagaStatus.RUNNING
        start_time = datetime.utcnow()

        try:
            # Execute steps in order
            for step in self._steps:
                step_result = await self._execute_step(step, context)

                # Store result
                context.step_results.append({
                    "step": step.name,
                    "result": step_result,
                    "timestamp": datetime.utcnow().isoformat()
                })

                self._completed_steps.append(step.name)

            # All steps completed successfully
            self._status = SagaStatus.COMPLETED
            duration = (datetime.utcnow() - start_time).total_seconds()

            return {
                "status": self._status.value,
                "saga_id": str(context.saga_id),
                "completed_steps": self._completed_steps,
                "duration_seconds": duration,
                "data": context.data
            }

        except Exception as e:
            # Step failed - compensate
            self._status = SagaStatus.COMPENSATING
            self._failed_step = self._completed_steps[-1] if self._completed_steps else None
            self._error = str(e)

            try:
                await self._compensate(context)
                self._status = SagaStatus.COMPENSATED
            except Exception as comp_error:
                self._status = SagaStatus.FAILED
                self._error = f"Original error: {e}. Compensation failed: {comp_error}"

            duration = (datetime.utcnow() - start_time).total_seconds()

            return {
                "status": self._status.value,
                "saga_id": str(context.saga_id),
                "completed_steps": self._completed_steps,
                "failed_step": self._failed_step,
                "error": self._error,
                "duration_seconds": duration
            }

    async def _execute_step(self, step: SagaStep, context: SagaContext) -> Any:
        """Execute a single saga step with retries.

        Args:
            step: Step to execute
            context: Saga context

        Returns:
            Step result

        Raises:
            Exception: If step fails after retries
        """
        import asyncio

        last_error = None

        for attempt in range(step.retries + 1):
            try:
                # Execute with timeout
                result = await asyncio.wait_for(
                    step.action(context),
                    timeout=step.timeout_seconds
                )
                return result

            except asyncio.TimeoutError as e:
                last_error = TimeoutError(
                    f"Step '{step.name}' timed out after {step.timeout_seconds}s"
                )
                if attempt < step.retries:
                    continue  # Retry
                raise last_error from e

            except Exception as e:
                last_error = e
                if attempt < step.retries:
                    continue  # Retry
                raise

        # Should not reach here, but just in case
        if last_error:
            raise last_error
        raise RuntimeError(f"Step '{step.name}' failed with unknown error")

    async def _compensate(self, context: SagaContext):
        """Compensate completed steps in reverse order.

        Args:
            context: Saga context

        Raises:
            Exception: If compensation fails
        """
        import asyncio

        # Compensate in reverse order
        for step_name in reversed(self._completed_steps):
            # Find step
            step = next((s for s in self._steps if s.name == step_name), None)

            if step and step.compensation:
                try:
                    await asyncio.wait_for(
                        step.compensation(context),
                        timeout=step.timeout_seconds
                    )
                except asyncio.TimeoutError as e:
                    raise TimeoutError(
                        f"Compensation for '{step.name}' timed out"
                    ) from e
                except Exception as e:
                    raise RuntimeError(
                        f"Compensation failed for step '{step.name}': {str(e)}"
                    ) from e

    def get_status(self) -> Dict[str, Any]:
        """Get saga execution status.

        Returns:
            Status information
        """
        return {
            "status": self._status.value,
            "steps": [step.name for step in self._steps],
            "completed_steps": self._completed_steps,
            "failed_step": self._failed_step,
            "error": self._error
        }


# ============================================================================
# Factory Function
# ============================================================================


def create_saga() -> Saga:
    """Create a new saga instance.

    Returns:
        Saga orchestrator
    """
    return Saga()


# ============================================================================
# Example Saga for {{ capability_name }}
# ============================================================================


async def create_entity_saga(entity_data: Dict[str, Any]) -> Dict[str, Any]:
    """Example saga for creating an entity with multiple steps.

    This is a reference implementation showing how to use sagas
    for complex multi-step operations.

    Args:
        entity_data: Entity data

    Returns:
        Saga execution result
    """
    saga = create_saga()
    context = SagaContext(data=entity_data)

    # Step 1: Validate data
    async def validate_data(ctx: SagaContext):
        """Validate entity data."""
        # Validation logic
        return {"validated": True}

    async def undo_validation(ctx: SagaContext):
        """No-op compensation for validation."""
        pass

    saga.add_step(
        name="validate",
        action=validate_data,
        compensation=undo_validation
    )

    # Step 2: Reserve resources
    async def reserve_resources(ctx: SagaContext):
        """Reserve necessary resources."""
        # Resource reservation logic
        ctx.data["resource_id"] = "res-123"
        return {"resource_id": ctx.data["resource_id"]}

    async def release_resources(ctx: SagaContext):
        """Release reserved resources."""
        # Resource release logic
        del ctx.data["resource_id"]

    saga.add_step(
        name="reserve_resources",
        action=reserve_resources,
        compensation=release_resources,
        retries=2
    )

    # Step 3: Create entity
    async def create_entity(ctx: SagaContext):
        """Create the entity."""
        # Entity creation logic
        ctx.data["entity_id"] = "entity-123"
        return {"entity_id": ctx.data["entity_id"]}

    async def delete_entity(ctx: SagaContext):
        """Delete created entity."""
        # Entity deletion logic
        del ctx.data["entity_id"]

    saga.add_step(
        name="create_entity",
        action=create_entity,
        compensation=delete_entity
    )

    # Execute saga
    return await saga.execute(context)
