"""{{ capability_name }} - Circuit Breaker Pattern (SAP-046)

Circuit breaker for failure isolation and cascading failure prevention.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

import asyncio
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable, Optional


# ============================================================================
# Circuit State Enum
# ============================================================================


class CircuitState(str, Enum):
    """Circuit breaker states."""

    CLOSED = "closed"  # Normal operation
    OPEN = "open"  # Failing - reject requests
    HALF_OPEN = "half_open"  # Testing - allow limited requests


# ============================================================================
# Circuit Breaker Exception
# ============================================================================


class CircuitBreakerOpen(Exception):
    """Raised when circuit breaker is open."""

    def __init__(self, message: str = "Circuit breaker is open"):
        self.message = message
        super().__init__(self.message)


# ============================================================================
# Circuit Breaker Implementation
# ============================================================================


class CircuitBreaker:
    """Circuit breaker pattern implementation.

    Prevents cascading failures by stopping requests to failing services.
    Automatically recovers by testing service health after timeout.

    States:
    - CLOSED: Normal operation, all requests allowed
    - OPEN: Service is failing, all requests rejected
    - HALF_OPEN: Testing recovery, limited requests allowed
    """

    def __init__(
        self,
        failure_threshold: int = 5,
        recovery_timeout_seconds: int = 60,
        success_threshold: int = 2,
        timeout_seconds: int = 30
    ):
        """Initialize circuit breaker.

        Args:
            failure_threshold: Failures before opening circuit
            recovery_timeout_seconds: Seconds before testing recovery
            success_threshold: Successes needed to close from half-open
            timeout_seconds: Request timeout in seconds
        """
        self.failure_threshold = failure_threshold
        self.recovery_timeout = timedelta(seconds=recovery_timeout_seconds)
        self.success_threshold = success_threshold
        self.request_timeout = timeout_seconds

        self._state = CircuitState.CLOSED
        self._failure_count = 0
        self._success_count = 0
        self._last_failure_time: Optional[datetime] = None

    @property
    def state(self) -> CircuitState:
        """Get current circuit state."""
        self._check_state_transition()
        return self._state

    async def call(self, func: Callable, *args, **kwargs) -> Any:
        """Execute function through circuit breaker.

        Args:
            func: Async function to execute
            *args: Function arguments
            **kwargs: Function keyword arguments

        Returns:
            Function result

        Raises:
            CircuitBreakerOpen: If circuit is open
            TimeoutError: If request times out
            Exception: If function raises exception
        """
        self._check_state_transition()

        # Reject if circuit is open
        if self._state == CircuitState.OPEN:
            raise CircuitBreakerOpen(
                f"Circuit breaker is open (failures: {self._failure_count})"
            )

        try:
            # Execute with timeout
            result = await asyncio.wait_for(
                func(*args, **kwargs),
                timeout=self.request_timeout
            )

            # Success - record it
            self._on_success()
            return result

        except asyncio.TimeoutError as e:
            # Timeout counts as failure
            self._on_failure()
            raise TimeoutError(f"Request timed out after {self.request_timeout}s") from e

        except Exception as e:
            # Failure - record it
            self._on_failure()
            raise

    def reset(self):
        """Manually reset circuit breaker to closed state."""
        self._state = CircuitState.CLOSED
        self._failure_count = 0
        self._success_count = 0
        self._last_failure_time = None

    def get_metrics(self) -> dict:
        """Get circuit breaker metrics.

        Returns:
            Metrics dictionary
        """
        return {
            "state": self._state.value,
            "failure_count": self._failure_count,
            "success_count": self._success_count,
            "failure_threshold": self.failure_threshold,
            "success_threshold": self.success_threshold,
            "last_failure_time": (
                self._last_failure_time.isoformat()
                if self._last_failure_time
                else None
            ),
            "recovery_timeout_seconds": self.recovery_timeout.total_seconds()
        }

    def _on_success(self):
        """Handle successful request."""
        if self._state == CircuitState.HALF_OPEN:
            self._success_count += 1

            # Enough successes - close circuit
            if self._success_count >= self.success_threshold:
                self._state = CircuitState.CLOSED
                self._failure_count = 0
                self._success_count = 0
                self._last_failure_time = None

        elif self._state == CircuitState.CLOSED:
            # Reset failure count on success in closed state
            self._failure_count = 0

    def _on_failure(self):
        """Handle failed request."""
        self._failure_count += 1
        self._last_failure_time = datetime.utcnow()

        if self._state == CircuitState.HALF_OPEN:
            # Failure during testing - reopen circuit
            self._state = CircuitState.OPEN
            self._success_count = 0

        elif self._state == CircuitState.CLOSED:
            # Too many failures - open circuit
            if self._failure_count >= self.failure_threshold:
                self._state = CircuitState.OPEN
                self._success_count = 0

    def _check_state_transition(self):
        """Check if circuit should transition from OPEN to HALF_OPEN."""
        if self._state == CircuitState.OPEN and self._last_failure_time:
            time_since_failure = datetime.utcnow() - self._last_failure_time

            # Recovery timeout elapsed - test recovery
            if time_since_failure >= self.recovery_timeout:
                self._state = CircuitState.HALF_OPEN
                self._success_count = 0
                # Keep failure count to track history


# ============================================================================
# Decorator for Circuit Breaker
# ============================================================================


def with_circuit_breaker(breaker: CircuitBreaker):
    """Decorator to wrap function with circuit breaker.

    Args:
        breaker: Circuit breaker instance

    Returns:
        Decorated function

    Example:
        ```python
        breaker = CircuitBreaker()

        @with_circuit_breaker(breaker)
        async def call_external_api():
            # API call
            pass
        ```
    """
    def decorator(func: Callable):
        async def wrapper(*args, **kwargs):
            return await breaker.call(func, *args, **kwargs)
        return wrapper
    return decorator
