"""{{ capability_name }} - Event Bus Pattern (SAP-046)

Asynchronous event-driven communication for loosely coupled components.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

import asyncio
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field


# ============================================================================
# Event Model
# ============================================================================


class Event(BaseModel):
    """Domain event."""

    event_id: UUID = Field(
        default_factory=uuid4,
        description="Unique event identifier"
    )

    event_type: str = Field(
        ...,
        description="Event type (e.g., 'entity.created', 'entity.updated')"
    )

    source: str = Field(
        ...,
        description="Event source (e.g., 'core.service', 'rest.api')"
    )

    data: Dict[str, Any] = Field(
        default_factory=dict,
        description="Event payload"
    )

    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Event metadata (correlation_id, user_id, etc.)"
    )

    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        description="Event timestamp"
    )

    model_config = {
        "json_schema_extra": {
            "example": {
                "event_type": "entity.created",
                "source": "core.service",
                "data": {
                    "entity_id": "123e4567-e89b-12d3-a456-426614174000",
                    "entity_name": "New Entity"
                },
                "metadata": {
                    "correlation_id": "abc-123",
                    "user_id": "user-456"
                }
            }
        }
    }


# ============================================================================
# Event Handler Type
# ============================================================================


EventHandler = Callable[[Event], Any]


# ============================================================================
# Event Bus Implementation
# ============================================================================


class EventBus:
    """In-memory event bus for publish-subscribe pattern.

    Enables loose coupling between components through asynchronous
    event-driven communication. For production with persistence,
    integrate with message brokers (RabbitMQ, Kafka, etc.).
    """

    def __init__(self):
        """Initialize event bus."""
        self._handlers: Dict[str, List[EventHandler]] = {}
        self._event_history: List[Event] = []
        self._max_history_size = 1000

    def subscribe(self, event_type: str, handler: EventHandler):
        """Subscribe to events of a specific type.

        Args:
            event_type: Event type to subscribe to (e.g., 'entity.created')
            handler: Async function to handle events

        Example:
            ```python
            async def on_entity_created(event: Event):
                print(f"Entity created: {event.data['entity_id']}")

            bus.subscribe("entity.created", on_entity_created)
            ```
        """
        if event_type not in self._handlers:
            self._handlers[event_type] = []

        self._handlers[event_type].append(handler)

    def unsubscribe(self, event_type: str, handler: EventHandler) -> bool:
        """Unsubscribe from events.

        Args:
            event_type: Event type
            handler: Handler to remove

        Returns:
            True if unsubscribed, False if not found
        """
        if event_type in self._handlers:
            try:
                self._handlers[event_type].remove(handler)
                return True
            except ValueError:
                return False
        return False

    async def publish(
        self,
        event_type: str,
        source: str,
        data: Optional[Dict[str, Any]] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Event:
        """Publish an event.

        Args:
            event_type: Event type
            source: Event source
            data: Event payload
            metadata: Event metadata

        Returns:
            Published event

        Example:
            ```python
            await bus.publish(
                event_type="entity.created",
                source="core.service",
                data={"entity_id": str(entity.id)},
                metadata={"correlation_id": "abc-123"}
            )
            ```
        """
        event = Event(
            event_type=event_type,
            source=source,
            data=data or {},
            metadata=metadata or {}
        )

        # Store in history
        self._add_to_history(event)

        # Notify handlers asynchronously
        await self._notify_handlers(event)

        return event

    async def publish_event(self, event: Event):
        """Publish an existing event object.

        Args:
            event: Event to publish
        """
        self._add_to_history(event)
        await self._notify_handlers(event)

    def get_history(
        self,
        event_type: Optional[str] = None,
        limit: int = 100
    ) -> List[Event]:
        """Get event history.

        Args:
            event_type: Optional filter by event type
            limit: Maximum events to return

        Returns:
            List of events (most recent first)
        """
        events = self._event_history

        if event_type:
            events = [e for e in events if e.event_type == event_type]

        return list(reversed(events[-limit:]))

    def get_subscribers(self, event_type: str) -> int:
        """Get number of subscribers for event type.

        Args:
            event_type: Event type

        Returns:
            Number of subscribers
        """
        return len(self._handlers.get(event_type, []))

    def clear_history(self):
        """Clear event history."""
        self._event_history = []

    async def _notify_handlers(self, event: Event):
        """Notify all handlers for event type.

        Args:
            event: Event to dispatch
        """
        handlers = self._handlers.get(event.event_type, [])

        # Call all handlers concurrently
        if handlers:
            tasks = [self._call_handler(handler, event) for handler in handlers]
            await asyncio.gather(*tasks, return_exceptions=True)

    async def _call_handler(self, handler: EventHandler, event: Event):
        """Call a single handler with error handling.

        Args:
            handler: Event handler
            event: Event to handle
        """
        try:
            result = handler(event)
            # Handle both sync and async handlers
            if asyncio.iscoroutine(result):
                await result
        except Exception as e:
            # Log error but don't propagate (one handler failure shouldn't affect others)
            print(f"Error in event handler: {e}")

    def _add_to_history(self, event: Event):
        """Add event to history with size limit.

        Args:
            event: Event to add
        """
        self._event_history.append(event)

        # Trim history if too large
        if len(self._event_history) > self._max_history_size:
            self._event_history = self._event_history[-self._max_history_size:]


# ============================================================================
# Global Event Bus Instance
# ============================================================================


_event_bus: Optional[EventBus] = None


def get_event_bus() -> EventBus:
    """Get or create global event bus instance.

    Returns:
        Shared event bus
    """
    global _event_bus
    if _event_bus is None:
        _event_bus = EventBus()
    return _event_bus


# ============================================================================
# Decorator for Event Publishing
# ============================================================================


def publishes_event(event_type: str, source: str):
    """Decorator to automatically publish events after function execution.

    Args:
        event_type: Event type to publish
        source: Event source

    Returns:
        Decorated function

    Example:
        ```python
        @publishes_event("entity.created", "core.service")
        async def create_entity(request):
            entity = Entity(...)
            return entity
        ```
    """
    def decorator(func: Callable):
        async def wrapper(*args, **kwargs):
            result = await func(*args, **kwargs)

            # Publish event with result as data
            bus = get_event_bus()
            await bus.publish(
                event_type=event_type,
                source=source,
                data={"result": result} if result else {}
            )

            return result
        return wrapper
    return decorator
