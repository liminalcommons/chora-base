"""{{ capability_name }} - Service Registry Implementation (SAP-044)

In-memory service registry for capability discovery and health monitoring.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field


# ============================================================================
# Service Status Enum
# ============================================================================


class ServiceStatus(str, Enum):
    """Service health status."""

    STARTING = "starting"
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"
    STOPPING = "stopping"
    STOPPED = "stopped"


# ============================================================================
# Service Registration Model
# ============================================================================


class ServiceRegistration(BaseModel):
    """Service registration metadata."""

    service_id: UUID = Field(
        default_factory=uuid4,
        description="Unique service instance ID"
    )

    service_name: str = Field(
        ...,
        description="Human-readable service name"
    )

    service_type: str = Field(
        ...,
        description="Service type (e.g., 'capability-server', 'gateway')"
    )

    version: str = Field(
        ...,
        description="Service version"
    )

    capabilities: List[str] = Field(
        default_factory=list,
        description="List of capabilities this service provides"
    )

    interfaces: List[str] = Field(
        default_factory=list,
        description="Available interfaces (cli, rest, mcp)"
    )

    endpoints: Dict[str, str] = Field(
        default_factory=dict,
        description="Interface endpoints (e.g., {'rest': 'http://localhost:8000'})"
    )

    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional service metadata"
    )

    status: ServiceStatus = Field(
        default=ServiceStatus.STARTING,
        description="Current service status"
    )

    registered_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Registration timestamp"
    )

    last_heartbeat: datetime = Field(
        default_factory=datetime.utcnow,
        description="Last heartbeat timestamp"
    )

    model_config = {
        "json_schema_extra": {
            "example": {
                "service_name": "{{ capability_name }}",
                "service_type": "capability-server",
                "version": "1.0.0",
                "capabilities": ["{{ namespace }}:create", "{{ namespace }}:list"],
                "interfaces": ["cli", "rest", "mcp"],
                "endpoints": {
                    "rest": "http://localhost:8000",
                    "mcp": "stdio"
                }
            }
        }
    }

    def to_dict(self) -> Dict[str, Any]:
        """Convert registration to dictionary.

        Returns:
            Dictionary representation of registration
        """
        return {
            "service_id": str(self.service_id),
            "service_name": self.service_name,
            "service_type": self.service_type,
            "version": self.version,
            "capabilities": self.capabilities,
            "interfaces": self.interfaces,
            "endpoints": self.endpoints,
            "metadata": self.metadata,
            "status": self.status.value,
            "registered_at": self.registered_at.isoformat(),
            "last_heartbeat": self.last_heartbeat.isoformat()
        }


# ============================================================================
# Service Registry
# ============================================================================


class ServiceRegistry:
    """In-memory service registry.

    Provides service discovery, health monitoring, and capability lookup.
    For production with persistence, implement a registry backed by
    Redis, etcd, or Consul.
    """

    def __init__(self, heartbeat_timeout_seconds: int = 30):
        """Initialize registry.

        Args:
            heartbeat_timeout_seconds: Seconds before service considered unhealthy
        """
        self._services: Dict[UUID, ServiceRegistration] = {}
        self._heartbeat_timeout = timedelta(seconds=heartbeat_timeout_seconds)

    def register(
        self,
        service_name: str,
        service_type: str,
        version: str,
        capabilities: List[str],
        interfaces: List[str],
        endpoints: Dict[str, str],
        metadata: Optional[Dict[str, Any]] = None
    ) -> ServiceRegistration:
        """Register a new service.

        Args:
            service_name: Human-readable service name
            service_type: Service type
            version: Service version
            capabilities: List of capabilities
            interfaces: Available interfaces
            endpoints: Interface endpoints
            metadata: Optional metadata

        Returns:
            Service registration
        """
        registration = ServiceRegistration(
            service_name=service_name,
            service_type=service_type,
            version=version,
            capabilities=capabilities,
            interfaces=interfaces,
            endpoints=endpoints,
            metadata=metadata or {},
            status=ServiceStatus.HEALTHY,
        )

        self._services[registration.service_id] = registration
        return registration

    def deregister(self, service_id: UUID) -> bool:
        """Deregister a service.

        Args:
            service_id: Service ID to deregister

        Returns:
            True if deregistered, False if not found
        """
        if service_id in self._services:
            # Mark as stopped before removing
            self._services[service_id].status = ServiceStatus.STOPPED
            del self._services[service_id]
            return True
        return False

    def heartbeat(self, service_id: UUID) -> bool:
        """Update service heartbeat.

        Args:
            service_id: Service ID

        Returns:
            True if updated, False if not found
        """
        if service_id in self._services:
            self._services[service_id].last_heartbeat = datetime.utcnow()
            # Update status to healthy if it was degraded
            if self._services[service_id].status == ServiceStatus.DEGRADED:
                self._services[service_id].status = ServiceStatus.HEALTHY
            return True
        return False

    def update_status(self, service_id: UUID, status: ServiceStatus) -> bool:
        """Update service status.

        Args:
            service_id: Service ID
            status: New status

        Returns:
            True if updated, False if not found
        """
        if service_id in self._services:
            self._services[service_id].status = status
            return True
        return False

    def get_service(self, service_id: UUID) -> Optional[ServiceRegistration]:
        """Get service by ID.

        Args:
            service_id: Service ID

        Returns:
            Service registration or None
        """
        self._check_heartbeats()
        return self._services.get(service_id)

    def list_services(
        self,
        service_type: Optional[str] = None,
        status: Optional[ServiceStatus] = None,
        capability: Optional[str] = None,
        interface: Optional[str] = None
    ) -> List[ServiceRegistration]:
        """List services with optional filtering.

        Args:
            service_type: Filter by service type
            status: Filter by status
            capability: Filter by capability
            interface: Filter by interface

        Returns:
            List of service registrations
        """
        self._check_heartbeats()
        services = list(self._services.values())

        # Apply filters
        if service_type:
            services = [s for s in services if s.service_type == service_type]

        if status:
            services = [s for s in services if s.status == status]

        if capability:
            services = [s for s in services if capability in s.capabilities]

        if interface:
            services = [s for s in services if interface in s.interfaces]

        return services

    def discover_capability(self, capability: str) -> List[ServiceRegistration]:
        """Discover services providing a capability.

        Args:
            capability: Capability to find

        Returns:
            List of services providing the capability
        """
        return self.list_services(capability=capability, status=ServiceStatus.HEALTHY)

    def get_healthy_services(self) -> List[ServiceRegistration]:
        """Get all healthy services.

        Returns:
            List of healthy services
        """
        return self.list_services(status=ServiceStatus.HEALTHY)

    def health_check(self) -> Dict[str, Any]:
        """Get registry health status.

        Returns:
            Health status information
        """
        self._check_heartbeats()

        total = len(self._services)
        by_status = {}
        for status in ServiceStatus:
            count = len([s for s in self._services.values() if s.status == status])
            by_status[status.value] = count

        # Count services by type and interface
        services_by_type: Dict[str, int] = {}
        services_by_interface: Dict[str, int] = {}
        for service in self._services.values():
            # Count by type
            services_by_type[service.service_type] = services_by_type.get(service.service_type, 0) + 1
            # Count by interface
            for interface in service.interfaces:
                services_by_interface[interface] = services_by_interface.get(interface, 0) + 1

        return {
            "total_services": total,
            "by_status": by_status,
            "healthy_services": by_status.get(ServiceStatus.HEALTHY.value, 0),
            "unhealthy_services": by_status.get(ServiceStatus.UNHEALTHY.value, 0),
            "services_by_type": services_by_type,
            "services_by_interface": services_by_interface,
            "timestamp": datetime.utcnow().isoformat()
        }

    def mark_unhealthy(self, service_id: UUID, reason: Optional[str] = None) -> bool:
        """Mark a service as unhealthy.

        Args:
            service_id: Service ID to mark unhealthy
            reason: Optional reason for marking unhealthy (stored in metadata)

        Returns:
            True if marked, False if not found
        """
        if service_id in self._services and reason:
            self._services[service_id].metadata["error"] = reason
        return self.update_status(service_id, ServiceStatus.UNHEALTHY)

    def check_timeouts(self) -> List[UUID]:
        """Check for services with stale heartbeats.

        Returns:
            List of service IDs marked unhealthy or degraded
        """
        self._check_heartbeats()
        return [
            service_id
            for service_id, service in self._services.items()
            if service.status in (ServiceStatus.UNHEALTHY, ServiceStatus.DEGRADED)
        ]

    def get_stats(self) -> Dict[str, Any]:
        """Get registry statistics.

        Returns:
            Registry statistics
        """
        return self.health_check()

    def _check_heartbeats(self):
        """Check all services for stale heartbeats and update status."""
        now = datetime.utcnow()

        for service in self._services.values():
            if service.status in (ServiceStatus.STOPPING, ServiceStatus.STOPPED):
                continue

            time_since_heartbeat = now - service.last_heartbeat

            if time_since_heartbeat > self._heartbeat_timeout * 2:
                # No heartbeat for 2x timeout - mark unhealthy
                service.status = ServiceStatus.UNHEALTHY
                service.metadata["error"] = f"Heartbeat timeout: {time_since_heartbeat.total_seconds()}s"
            elif time_since_heartbeat > self._heartbeat_timeout:
                # No heartbeat for 1x timeout - mark degraded
                service.status = ServiceStatus.DEGRADED


# ============================================================================
# Global Registry Instance
# ============================================================================


_registry: Optional[ServiceRegistry] = None


def get_registry() -> ServiceRegistry:
    """Get or create global registry instance.

    Returns:
        Shared service registry
    """
    global _registry
    if _registry is None:
        _registry = ServiceRegistry()
    return _registry


# ============================================================================
# Helper Functions
# ============================================================================


def register_self(
    service_name: str,
    version: str,
    capabilities: List[str],
    interfaces: List[str],
    endpoints: Dict[str, str],
    metadata: Optional[Dict[str, Any]] = None
) -> ServiceRegistration:
    """Register this service in the registry.

    Args:
        service_name: Service name
        version: Service version
        capabilities: Capabilities provided
        interfaces: Available interfaces
        endpoints: Interface endpoints
        metadata: Optional metadata

    Returns:
        Service registration
    """
    registry = get_registry()
    return registry.register(
        service_name=service_name,
        service_type="capability-server",
        version=version,
        capabilities=capabilities,
        interfaces=interfaces,
        endpoints=endpoints,
        metadata=metadata
    )
