"""{{ capability_name }} - MCP Tools (SAP-043)

MCP tool definitions. Tools are functions that AI assistants can call
to interact with the {{ capability_name_snake }} capability.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

from typing import Any, Dict, List, Optional
from uuid import UUID

from fastmcp import FastMCP
from pydantic import ValidationError

from {{ package_name }}.core import (
    {{ capability_name_pascal }}Error,
    {{ capability_name_pascal }}Filter,
    {{ capability_name_pascal }}Request,
    {{ capability_name_pascal }}Service,
    {{ capability_name_pascal }}Status,
    create_{{ capability_name_snake }}_service,
)


# ============================================================================
# Namespace Configuration
# ============================================================================


NAMESPACE = "{{ namespace }}"


def make_tool_name(tool: str) -> str:
    """Create namespaced tool name.

    Args:
        tool: Tool name

    Returns:
        Namespaced tool name (e.g., "namespace:tool")
    """
    return f"{NAMESPACE}:{tool}"


# ============================================================================
# Tool Executor (Testable Tool Logic)
# ============================================================================


class ToolExecutor:
    """Executor for MCP tools with injectable service.

    This class contains all tool logic and can be instantiated with a
    service for testing, maintaining service state across tool calls.
    """

    def __init__(self, service: Optional[{{ capability_name_pascal }}Service] = None):
        """Initialize tool executor.

        Args:
            service: Optional service instance (creates new if not provided)
        """
        self.service = service or create_{{ capability_name_snake }}_service()

    async def create_entity(
        self,
        name: str,
        description: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Create a new {{ capability_name_snake }} entity.

        Args:
            name: Entity name (required, 1-200 characters)
            description: Optional description (max 2000 characters)
            metadata: Optional metadata as key-value pairs

        Returns:
            Created entity as dictionary
        """
        try:
            request = {{ capability_name_pascal }}Request(
                name=name,
                description=description,
                metadata=metadata or {}
            )

            response = await self.service.create(request)

            return {
                "success": True,
                "message": response.message,
                "entity": response.entity.to_dict()
            }

        except ValidationError as e:
            return {
                "success": False,
                "error": "VALIDATION_ERROR",
                "message": str(e),
                "details": {"validation_errors": e.errors()}
            }
        except {{ capability_name_pascal }}Error as e:
            return {
                "success": False,
                "error": e.code,
                "message": e.message,
                "details": e.details
            }

    async def get_entity(self, entity_id: str) -> Dict[str, Any]:
        """Get a {{ capability_name_snake }} entity by ID.

        Args:
            entity_id: Entity UUID

        Returns:
            Entity as dictionary
        """
        try:
            uuid = UUID(entity_id)
            entity = await self.service.get(uuid)

            return {
                "success": True,
                "entity": entity.to_dict()
            }

        except ValueError:
            return {
                "success": False,
                "error": "INVALID_UUID",
                "message": f"Invalid UUID format: {entity_id}"
            }
        except {{ capability_name_pascal }}Error as e:
            return {
                "success": False,
                "error": e.code,
                "message": e.message,
                "details": e.details
            }

    async def list_entities(
        self,
        status: Optional[str] = None,
        name_contains: Optional[str] = None,
        offset: int = 0,
        limit: int = 100
    ) -> Dict[str, Any]:
        """List {{ capability_name_snake }} entities with optional filtering.

        Args:
            status: Optional status filter (pending, active, completed, failed, cancelled)
            name_contains: Optional name search (case-insensitive)
            offset: Pagination offset (default: 0)
            limit: Maximum results (default: 100, max: 1000)

        Returns:
            List of entities with pagination metadata
        """
        try:
            # Convert status string to enum if provided
            status_enum = None
            if status:
                try:
                    status_enum = {{ capability_name_pascal }}Status(status.lower())
                except ValueError:
                    return {
                        "success": False,
                        "error": "INVALID_STATUS",
                        "message": f"Invalid status: {status}",
                        "valid_statuses": [s.value for s in {{ capability_name_pascal }}Status]
                    }

            filters = {{ capability_name_pascal }}Filter(
                status=status_enum,
                name_contains=name_contains,
                offset=offset,
                limit=limit
            )

            response = await self.service.list(filters)

            return {
                "success": True,
                "entities": [e.to_dict() for e in response.entities],
                "total": response.total,
                "offset": response.offset,
                "limit": response.limit
            }

        except {{ capability_name_pascal }}Error as e:
            return {
                "success": False,
                "error": e.code,
                "message": e.message,
                "details": e.details
            }

    async def update_entity(
        self,
        entity_id: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Update a {{ capability_name_snake }} entity.

        Only provided fields will be updated. Omitted fields remain unchanged.

        Args:
            entity_id: Entity UUID
            name: Optional new name
            description: Optional new description
            metadata: Optional new metadata (replaces existing)

        Returns:
            Updated entity as dictionary
        """
        try:
            uuid = UUID(entity_id)

            # Get existing entity
            existing = await self.service.get(uuid)

            # Merge with existing values
            request = {{ capability_name_pascal }}Request(
                name=name if name else existing.name,
                description=description if description is not None else existing.description,
                metadata=metadata if metadata is not None else existing.metadata
            )

            response = await self.service.update(uuid, request)

            return {
                "success": True,
                "message": response.message,
                "entity": response.entity.to_dict()
            }

        except ValueError:
            return {
                "success": False,
                "error": "INVALID_UUID",
                "message": f"Invalid UUID format: {entity_id}"
            }
        except {{ capability_name_pascal }}Error as e:
            return {
                "success": False,
                "error": e.code,
                "message": e.message,
                "details": e.details
            }

    async def delete_entity(self, entity_id: str) -> Dict[str, Any]:
        """Delete a {{ capability_name_snake }} entity.

        Args:
            entity_id: Entity UUID

        Returns:
            Success confirmation
        """
        try:
            uuid = UUID(entity_id)
            await self.service.delete(uuid)

            return {
                "success": True,
                "message": f"Entity {entity_id} deleted successfully"
            }

        except ValueError:
            return {
                "success": False,
                "error": "INVALID_UUID",
                "message": f"Invalid UUID format: {entity_id}"
            }
        except {{ capability_name_pascal }}Error as e:
            return {
                "success": False,
                "error": e.code,
                "message": e.message,
                "details": e.details
            }

    async def update_status(
        self,
        entity_id: str,
        new_status: str
    ) -> Dict[str, Any]:
        """Update entity status.

        Args:
            entity_id: Entity UUID
            new_status: New status (pending, active, completed, failed, cancelled)

        Returns:
            Updated entity as dictionary
        """
        try:
            uuid = UUID(entity_id)

            # Convert status string to enum
            try:
                status_enum = {{ capability_name_pascal }}Status(new_status.lower())
            except ValueError:
                return {
                    "success": False,
                    "error": "INVALID_STATUS",
                    "message": f"Invalid status: {new_status}",
                    "valid_statuses": [s.value for s in {{ capability_name_pascal }}Status]
                }

            response = await self.service.update_status(uuid, status_enum)

            return {
                "success": True,
                "message": response.message,
                "entity": response.entity.to_dict()
            }

        except ValueError:
            return {
                "success": False,
                "error": "INVALID_UUID",
                "message": f"Invalid UUID format: {entity_id}"
            }
        except {{ capability_name_pascal }}Error as e:
            return {
                "success": False,
                "error": e.code,
                "message": e.message,
                "details": e.details
            }

    async def health_check(self) -> Dict[str, Any]:
        """Check service health status.

        Returns:
            Health status information
        """
        try:
            health = await self.service.health_check()

            return {
                "success": True,
                "health": health
            }

        except {{ capability_name_pascal }}Error as e:
            return {
                "success": False,
                "error": e.code,
                "message": e.message,
                "details": e.details
            }


# ============================================================================
# Tool Registration
# ============================================================================


def register_tools(mcp: FastMCP, executor: Optional[ToolExecutor] = None):
    """Register all MCP tools.

    Args:
        mcp: FastMCP server instance
        executor: Optional ToolExecutor instance (creates new if not provided)
    """
    # Create executor if not provided
    if executor is None:
        executor = ToolExecutor()

    # ========================================================================
    # Create Entity Tool
    # ========================================================================

    @mcp.tool(name=make_tool_name("create"))
    async def create_entity(
        name: str,
        description: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Create a new {{ capability_name_snake }} entity.

        Args:
            name: Entity name (required, 1-200 characters)
            description: Optional description (max 2000 characters)
            metadata: Optional metadata as key-value pairs

        Returns:
            Created entity as dictionary
        """
        return await executor.create_entity(name, description, metadata)

    # ========================================================================
    # Get Entity Tool
    # ========================================================================

    @mcp.tool(name=make_tool_name("get"))
    async def get_entity(entity_id: str) -> Dict[str, Any]:
        """Get a {{ capability_name_snake }} entity by ID.

        Args:
            entity_id: Entity UUID

        Returns:
            Entity as dictionary
        """
        return await executor.get_entity(entity_id)

    # ========================================================================
    # List Entities Tool
    # ========================================================================

    @mcp.tool(name=make_tool_name("list"))
    async def list_entities(
        status: Optional[str] = None,
        name_contains: Optional[str] = None,
        offset: int = 0,
        limit: int = 100
    ) -> Dict[str, Any]:
        """List {{ capability_name_snake }} entities with optional filtering.

        Args:
            status: Optional status filter (pending, active, completed, failed, cancelled)
            name_contains: Optional name search (case-insensitive)
            offset: Pagination offset (default: 0)
            limit: Maximum results (default: 100, max: 1000)

        Returns:
            List of entities with pagination metadata
        """
        return await executor.list_entities(status, name_contains, offset, limit)

    # ========================================================================
    # Update Entity Tool
    # ========================================================================

    @mcp.tool(name=make_tool_name("update"))
    async def update_entity(
        entity_id: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Update a {{ capability_name_snake }} entity.

        Only provided fields will be updated. Omitted fields remain unchanged.

        Args:
            entity_id: Entity UUID
            name: Optional new name
            description: Optional new description
            metadata: Optional new metadata (replaces existing)

        Returns:
            Updated entity as dictionary
        """
        return await executor.update_entity(entity_id, name, description, metadata)

    # ========================================================================
    # Delete Entity Tool
    # ========================================================================

    @mcp.tool(name=make_tool_name("delete"))
    async def delete_entity(entity_id: str) -> Dict[str, Any]:
        """Delete a {{ capability_name_snake }} entity.

        Args:
            entity_id: Entity UUID

        Returns:
            Success confirmation
        """
        return await executor.delete_entity(entity_id)

    # ========================================================================
    # Update Status Tool
    # ========================================================================

    @mcp.tool(name=make_tool_name("update_status"))
    async def update_status(
        entity_id: str,
        new_status: str
    ) -> Dict[str, Any]:
        """Update entity status.

        Args:
            entity_id: Entity UUID
            new_status: New status (pending, active, completed, failed, cancelled)

        Returns:
            Updated entity as dictionary
        """
        return await executor.update_status(entity_id, new_status)

    # ========================================================================
    # Health Check Tool
    # ========================================================================

    @mcp.tool(name=make_tool_name("health"))
    async def health_check() -> Dict[str, Any]:
        """Check service health status.

        Returns:
            Health status information
        """
        return await executor.health_check()
