"""Tests for {{ capability_name }} Event Bus (SAP-046)

Tests verify event publishing, subscription, handler execution,
error isolation, and event history.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

import asyncio
from typing import List

import pytest

from {{ package_name }}.infrastructure.composition import (
    EventBus,
    Event,
)


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def event_bus():
    """Create event bus instance."""
    return EventBus(max_history=100)


@pytest.fixture
def event_log():
    """Shared list to track handler calls."""
    return []


# ============================================================================
# Test Event Publishing
# ============================================================================


class TestEventPublishing:
    """Test event publishing functionality."""

    @pytest.mark.asyncio
    async def test_publish_event(self, event_bus):
        """Test publishing an event."""
        event = await event_bus.publish(
            event_type="test.event",
            source="test",
            data={"key": "value"}
        )

        assert event.event_type == "test.event"
        assert event.source == "test"
        assert event.data["key"] == "value"
        assert len(str(event.event_id)) > 0

    @pytest.mark.asyncio
    async def test_publish_event_with_metadata(self, event_bus):
        """Test publishing event with metadata."""
        event = await event_bus.publish(
            event_type="test.event",
            source="test",
            data={"key": "value"},
            metadata={"user": "test-user"}
        )

        assert event.metadata["user"] == "test-user"

    @pytest.mark.asyncio
    async def test_publish_event_minimal(self, event_bus):
        """Test publishing event with minimal data."""
        event = await event_bus.publish(
            event_type="test.event",
            source="test"
        )

        assert event.data == {}
        assert event.metadata == {}

    @pytest.mark.asyncio
    async def test_publish_event_sets_timestamp(self, event_bus):
        """Test event has timestamp."""
        from datetime import datetime

        before = datetime.utcnow()
        event = await event_bus.publish(
            event_type="test.event",
            source="test"
        )
        after = datetime.utcnow()

        assert before <= event.timestamp <= after


# ============================================================================
# Test Event Subscription
# ============================================================================


class TestEventSubscription:
    """Test event subscription functionality."""

    @pytest.mark.asyncio
    async def test_subscribe_to_event(self, event_bus, event_log):
        """Test subscribing to an event type."""
        async def handler(event: Event):
            event_log.append(event.event_type)

        event_bus.subscribe("test.event", handler)

        await event_bus.publish("test.event", "test")

        # Wait for handler execution
        await asyncio.sleep(0.01)

        assert "test.event" in event_log

    @pytest.mark.asyncio
    async def test_multiple_subscribers(self, event_bus, event_log):
        """Test multiple subscribers to same event type."""
        async def handler1(event: Event):
            event_log.append("handler1")

        async def handler2(event: Event):
            event_log.append("handler2")

        async def handler3(event: Event):
            event_log.append("handler3")

        event_bus.subscribe("test.event", handler1)
        event_bus.subscribe("test.event", handler2)
        event_bus.subscribe("test.event", handler3)

        await event_bus.publish("test.event", "test")

        # Wait for handlers
        await asyncio.sleep(0.01)

        assert len(event_log) == 3
        assert "handler1" in event_log
        assert "handler2" in event_log
        assert "handler3" in event_log

    @pytest.mark.asyncio
    async def test_subscribe_to_different_events(self, event_bus, event_log):
        """Test subscribing to different event types."""
        async def handler_a(event: Event):
            event_log.append("a")

        async def handler_b(event: Event):
            event_log.append("b")

        event_bus.subscribe("event.a", handler_a)
        event_bus.subscribe("event.b", handler_b)

        await event_bus.publish("event.a", "test")
        await asyncio.sleep(0.01)

        # Only handler_a should have been called
        assert event_log == ["a"]

    @pytest.mark.asyncio
    async def test_unsubscribe_from_event(self, event_bus, event_log):
        """Test unsubscribing from event type."""
        async def handler(event: Event):
            event_log.append("called")

        event_bus.subscribe("test.event", handler)
        event_bus.unsubscribe("test.event", handler)

        await event_bus.publish("test.event", "test")
        await asyncio.sleep(0.01)

        # Handler should not have been called
        assert len(event_log) == 0

    @pytest.mark.asyncio
    async def test_unsubscribe_one_of_multiple(self, event_bus, event_log):
        """Test unsubscribing one handler while others remain."""
        async def handler1(event: Event):
            event_log.append("handler1")

        async def handler2(event: Event):
            event_log.append("handler2")

        event_bus.subscribe("test.event", handler1)
        event_bus.subscribe("test.event", handler2)

        # Unsubscribe handler1
        event_bus.unsubscribe("test.event", handler1)

        await event_bus.publish("test.event", "test")
        await asyncio.sleep(0.01)

        # Only handler2 should be called
        assert event_log == ["handler2"]


# ============================================================================
# Test Handler Execution
# ============================================================================


class TestHandlerExecution:
    """Test event handler execution."""

    @pytest.mark.asyncio
    async def test_handler_receives_event(self, event_bus):
        """Test handler receives full event object."""
        received_event = None

        async def handler(event: Event):
            nonlocal received_event
            received_event = event

        event_bus.subscribe("test.event", handler)

        await event_bus.publish(
            event_type="test.event",
            source="test-source",
            data={"key": "value"}
        )
        await asyncio.sleep(0.01)

        assert received_event is not None
        assert received_event.event_type == "test.event"
        assert received_event.source == "test-source"
        assert received_event.data["key"] == "value"

    @pytest.mark.asyncio
    async def test_handlers_run_concurrently(self, event_bus):
        """Test handlers run concurrently."""
        execution_times = []

        async def slow_handler(event: Event):
            await asyncio.sleep(0.1)
            execution_times.append("slow")

        async def fast_handler(event: Event):
            execution_times.append("fast")

        event_bus.subscribe("test.event", slow_handler)
        event_bus.subscribe("test.event", fast_handler)

        import time
        start = time.time()
        await event_bus.publish("test.event", "test")
        await asyncio.sleep(0.15)  # Wait for slow handler
        duration = time.time() - start

        # Should complete in ~0.15s (concurrent), not ~0.2s (sequential)
        # Allow 0.3s tolerance for system variance
        assert duration < 0.3
        assert "fast" in execution_times
        assert "slow" in execution_times

    @pytest.mark.asyncio
    async def test_handler_error_isolation(self, event_bus, event_log):
        """Test error in one handler doesn't affect others."""
        async def failing_handler(event: Event):
            raise RuntimeError("Handler error")

        async def succeeding_handler(event: Event):
            event_log.append("success")

        event_bus.subscribe("test.event", failing_handler)
        event_bus.subscribe("test.event", succeeding_handler)

        await event_bus.publish("test.event", "test")
        await asyncio.sleep(0.01)

        # Succeeding handler should still run
        assert "success" in event_log

    @pytest.mark.asyncio
    async def test_handler_can_access_metadata(self, event_bus):
        """Test handler can access event metadata."""
        received_metadata = None

        async def handler(event: Event):
            nonlocal received_metadata
            received_metadata = event.metadata

        event_bus.subscribe("test.event", handler)

        await event_bus.publish(
            event_type="test.event",
            source="test",
            metadata={"user": "test-user", "request_id": "123"}
        )
        await asyncio.sleep(0.01)

        assert received_metadata["user"] == "test-user"
        assert received_metadata["request_id"] == "123"


# ============================================================================
# Test Event History
# ============================================================================


class TestEventHistory:
    """Test event history tracking."""

    @pytest.mark.asyncio
    async def test_event_stored_in_history(self, event_bus):
        """Test published events are stored in history."""
        await event_bus.publish("test.event", "test")

        history = event_bus.get_history()
        assert len(history) == 1
        assert history[0].event_type == "test.event"

    @pytest.mark.asyncio
    async def test_multiple_events_in_history(self, event_bus):
        """Test multiple events stored in history."""
        for i in range(5):
            await event_bus.publish(f"event.{i}", "test")

        history = event_bus.get_history()
        assert len(history) == 5

    @pytest.mark.asyncio
    async def test_history_limit(self):
        """Test history respects max_history limit."""
        event_bus = EventBus(max_history=10)

        # Publish 15 events (exceeds limit)
        for i in range(15):
            await event_bus.publish("test.event", "test")

        history = event_bus.get_history()

        # Should only keep last 10
        assert len(history) == 10

    @pytest.mark.asyncio
    async def test_history_ordered_chronologically(self, event_bus):
        """Test history is in chronological order."""
        for i in range(5):
            await event_bus.publish(f"event.{i}", "test")
            await asyncio.sleep(0.01)  # Ensure different timestamps

        history = event_bus.get_history()

        # Check timestamps are ascending
        for i in range(len(history) - 1):
            assert history[i].timestamp <= history[i + 1].timestamp

    @pytest.mark.asyncio
    async def test_get_history_by_event_type(self, event_bus):
        """Test filtering history by event type."""
        await event_bus.publish("event.a", "test")
        await event_bus.publish("event.b", "test")
        await event_bus.publish("event.a", "test")
        await event_bus.publish("event.c", "test")

        history = event_bus.get_history(event_type="event.a")

        assert len(history) == 2
        assert all(e.event_type == "event.a" for e in history)

    @pytest.mark.asyncio
    async def test_get_history_by_source(self, event_bus):
        """Test filtering history by source."""
        await event_bus.publish("test.event", "source-a")
        await event_bus.publish("test.event", "source-b")
        await event_bus.publish("test.event", "source-a")

        history = event_bus.get_history(source="source-a")

        assert len(history) == 2
        assert all(e.source == "source-a" for e in history)

    @pytest.mark.asyncio
    async def test_get_history_with_limit(self, event_bus):
        """Test limiting history results."""
        for i in range(10):
            await event_bus.publish("test.event", "test")

        history = event_bus.get_history(limit=5)

        assert len(history) == 5

    @pytest.mark.asyncio
    async def test_clear_history(self, event_bus):
        """Test clearing event history."""
        for i in range(5):
            await event_bus.publish("test.event", "test")

        assert len(event_bus.get_history()) == 5

        event_bus.clear_history()

        assert len(event_bus.get_history()) == 0


# ============================================================================
# Test Event Model
# ============================================================================


class TestEventModel:
    """Test Event model."""

    @pytest.mark.asyncio
    async def test_event_to_dict(self, event_bus):
        """Test converting event to dictionary."""
        event = await event_bus.publish(
            event_type="test.event",
            source="test-source",
            data={"key": "value"},
            metadata={"user": "test-user"}
        )

        event_dict = event.to_dict()

        assert event_dict["event_type"] == "test.event"
        assert event_dict["source"] == "test-source"
        assert event_dict["data"]["key"] == "value"
        assert event_dict["metadata"]["user"] == "test-user"
        assert "event_id" in event_dict
        assert "timestamp" in event_dict

    @pytest.mark.asyncio
    async def test_event_id_is_unique(self, event_bus):
        """Test each event has unique ID."""
        event1 = await event_bus.publish("test.event", "test")
        event2 = await event_bus.publish("test.event", "test")

        assert event1.event_id != event2.event_id


# ============================================================================
# Test Statistics
# ============================================================================


class TestStatistics:
    """Test event bus statistics."""

    @pytest.mark.asyncio
    async def test_initial_stats(self, event_bus):
        """Test initial statistics."""
        stats = event_bus.get_stats()

        assert stats["total_events"] == 0
        assert stats["events_by_type"] == {}
        assert stats["events_by_source"] == {}
        assert stats["total_subscribers"] == 0

    @pytest.mark.asyncio
    async def test_stats_track_events(self, event_bus):
        """Test statistics track published events."""
        await event_bus.publish("event.a", "source1")
        await event_bus.publish("event.b", "source1")
        await event_bus.publish("event.a", "source2")

        stats = event_bus.get_stats()

        assert stats["total_events"] == 3
        assert stats["events_by_type"]["event.a"] == 2
        assert stats["events_by_type"]["event.b"] == 1
        assert stats["events_by_source"]["source1"] == 2
        assert stats["events_by_source"]["source2"] == 1

    @pytest.mark.asyncio
    async def test_stats_track_subscribers(self, event_bus):
        """Test statistics track subscribers."""
        async def handler1(event: Event):
            pass

        async def handler2(event: Event):
            pass

        event_bus.subscribe("event.a", handler1)
        event_bus.subscribe("event.a", handler2)
        event_bus.subscribe("event.b", handler1)

        stats = event_bus.get_stats()

        assert stats["total_subscribers"] == 3
        assert stats["subscribers_by_type"]["event.a"] == 2
        assert stats["subscribers_by_type"]["event.b"] == 1


# ============================================================================
# Test Edge Cases
# ============================================================================


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    @pytest.mark.asyncio
    async def test_publish_with_no_subscribers(self, event_bus):
        """Test publishing event with no subscribers succeeds."""
        event = await event_bus.publish("test.event", "test")

        assert event.event_type == "test.event"
        # Should not raise exception

    @pytest.mark.asyncio
    async def test_unsubscribe_nonexistent_handler(self, event_bus):
        """Test unsubscribing non-existent handler doesn't error."""
        async def handler(event: Event):
            pass

        # Unsubscribe without subscribing first
        event_bus.unsubscribe("test.event", handler)

        # Should not raise exception
        assert True

    @pytest.mark.asyncio
    async def test_empty_event_type(self, event_bus):
        """Test publishing event with empty type."""
        event = await event_bus.publish("", "test")

        assert event.event_type == ""

    @pytest.mark.asyncio
    async def test_empty_source(self, event_bus):
        """Test publishing event with empty source."""
        event = await event_bus.publish("test.event", "")

        assert event.source == ""

    @pytest.mark.asyncio
    async def test_large_event_data(self, event_bus):
        """Test publishing event with large data payload."""
        large_data = {"data": "x" * 10000}  # 10KB string

        event = await event_bus.publish(
            event_type="test.event",
            source="test",
            data=large_data
        )

        assert len(event.data["data"]) == 10000

    @pytest.mark.asyncio
    async def test_handler_order_preservation(self, event_bus):
        """Test handlers are called in subscription order."""
        call_order = []

        async def handler1(event: Event):
            call_order.append(1)

        async def handler2(event: Event):
            call_order.append(2)

        async def handler3(event: Event):
            call_order.append(3)

        event_bus.subscribe("test.event", handler1)
        event_bus.subscribe("test.event", handler2)
        event_bus.subscribe("test.event", handler3)

        await event_bus.publish("test.event", "test")
        await asyncio.sleep(0.01)

        # Note: Due to concurrent execution, order may vary
        # This test just ensures all were called
        assert len(call_order) == 3
        assert set(call_order) == {1, 2, 3}
