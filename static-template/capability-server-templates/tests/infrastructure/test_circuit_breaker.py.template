"""Tests for {{ capability_name }} Circuit Breaker (SAP-046)

Tests verify circuit breaker states, failure thresholds, recovery,
timeout handling, and state transitions.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

import asyncio

import pytest

from {{ package_name }}.infrastructure.composition import (
    CircuitBreaker,
    CircuitState,
    CircuitBreakerOpen,
    CircuitBreakerTimeout,
)


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def circuit_breaker():
    """Create circuit breaker with short timeouts for testing."""
    return CircuitBreaker(
        failure_threshold=3,
        recovery_timeout_seconds=1,
        success_threshold=2,
        timeout_seconds=1.0
    )


@pytest.fixture
def fast_circuit_breaker():
    """Create circuit breaker with very short timeouts."""
    return CircuitBreaker(
        failure_threshold=2,
        recovery_timeout_seconds=0.1,
        success_threshold=1,
        timeout_seconds=0.5
    )


# ============================================================================
# Test State Transitions
# ============================================================================


class TestStateTransitions:
    """Test circuit breaker state transitions."""

    @pytest.mark.asyncio
    async def test_initial_state_closed(self, circuit_breaker):
        """Test circuit breaker starts in CLOSED state."""
        assert circuit_breaker.get_state() == CircuitState.CLOSED

    @pytest.mark.asyncio
    async def test_transition_to_open_on_failures(self, circuit_breaker):
        """Test transition to OPEN after failure threshold."""
        async def failing_function():
            raise RuntimeError("Failure")

        # Fail 3 times (threshold)
        for _ in range(3):
            with pytest.raises(RuntimeError):
                await circuit_breaker.call(failing_function)

        # Should be open now
        assert circuit_breaker.get_state() == CircuitState.OPEN

    @pytest.mark.asyncio
    async def test_transition_to_half_open_after_timeout(self, fast_circuit_breaker):
        """Test transition to HALF_OPEN after recovery timeout."""
        async def failing_function():
            raise RuntimeError("Failure")

        # Open the circuit
        for _ in range(2):  # fast_circuit_breaker has threshold=2
            with pytest.raises(RuntimeError):
                await fast_circuit_breaker.call(failing_function)

        assert fast_circuit_breaker.get_state() == CircuitState.OPEN

        # Wait for recovery timeout
        await asyncio.sleep(0.15)  # recovery_timeout_seconds=0.1

        # Check state (should transition to HALF_OPEN)
        fast_circuit_breaker._check_state_transition()
        assert fast_circuit_breaker.get_state() == CircuitState.HALF_OPEN

    @pytest.mark.asyncio
    async def test_transition_from_half_open_to_closed(self, fast_circuit_breaker):
        """Test transition from HALF_OPEN to CLOSED on success."""
        async def failing_function():
            raise RuntimeError("Failure")

        async def succeeding_function():
            return "success"

        # Open the circuit
        for _ in range(2):
            with pytest.raises(RuntimeError):
                await fast_circuit_breaker.call(failing_function)

        # Wait for recovery
        await asyncio.sleep(0.15)

        # Call succeeding function (should close circuit)
        result = await fast_circuit_breaker.call(succeeding_function)
        assert result == "success"
        assert fast_circuit_breaker.get_state() == CircuitState.CLOSED

    @pytest.mark.asyncio
    async def test_transition_from_half_open_to_open(self, fast_circuit_breaker):
        """Test transition from HALF_OPEN back to OPEN on failure."""
        async def failing_function():
            raise RuntimeError("Failure")

        # Open the circuit
        for _ in range(2):
            with pytest.raises(RuntimeError):
                await fast_circuit_breaker.call(failing_function)

        # Wait for recovery
        await asyncio.sleep(0.15)
        assert fast_circuit_breaker.get_state() == CircuitState.HALF_OPEN

        # Fail again (should reopen)
        with pytest.raises(RuntimeError):
            await fast_circuit_breaker.call(failing_function)

        assert fast_circuit_breaker.get_state() == CircuitState.OPEN


# ============================================================================
# Test Failure Handling
# ============================================================================


class TestFailureHandling:
    """Test failure detection and counting."""

    @pytest.mark.asyncio
    async def test_successful_calls_dont_increment_failure_count(self, circuit_breaker):
        """Test successful calls don't affect failure count."""
        async def succeeding_function():
            return "success"

        # Make several successful calls
        for _ in range(5):
            await circuit_breaker.call(succeeding_function)

        # Should still be closed
        assert circuit_breaker.get_state() == CircuitState.CLOSED

    @pytest.mark.asyncio
    async def test_failure_count_increments(self, circuit_breaker):
        """Test failure count increments on errors."""
        async def failing_function():
            raise RuntimeError("Failure")

        # Fail once
        with pytest.raises(RuntimeError):
            await circuit_breaker.call(failing_function)

        stats = circuit_breaker.get_stats()
        assert stats["failure_count"] == 1

        # Fail again
        with pytest.raises(RuntimeError):
            await circuit_breaker.call(failing_function)

        stats = circuit_breaker.get_stats()
        assert stats["failure_count"] == 2

    @pytest.mark.asyncio
    async def test_success_resets_failure_count(self, circuit_breaker):
        """Test successful call resets failure count in CLOSED state."""
        async def failing_function():
            raise RuntimeError("Failure")

        async def succeeding_function():
            return "success"

        # Fail twice (below threshold)
        for _ in range(2):
            with pytest.raises(RuntimeError):
                await circuit_breaker.call(failing_function)

        stats = circuit_breaker.get_stats()
        assert stats["failure_count"] == 2

        # Succeed (should reset)
        await circuit_breaker.call(succeeding_function)

        stats = circuit_breaker.get_stats()
        assert stats["failure_count"] == 0

    @pytest.mark.asyncio
    async def test_exception_propagated(self, circuit_breaker):
        """Test original exception is propagated."""
        async def custom_error_function():
            raise ValueError("Custom error")

        with pytest.raises(ValueError) as exc_info:
            await circuit_breaker.call(custom_error_function)

        assert "Custom error" in str(exc_info.value)


# ============================================================================
# Test Open State Behavior
# ============================================================================


class TestOpenStateBehavior:
    """Test behavior when circuit is open."""

    @pytest.mark.asyncio
    async def test_open_circuit_rejects_calls(self, circuit_breaker):
        """Test open circuit rejects calls immediately."""
        async def failing_function():
            raise RuntimeError("Failure")

        # Open the circuit
        for _ in range(3):
            with pytest.raises(RuntimeError):
                await circuit_breaker.call(failing_function)

        assert circuit_breaker.get_state() == CircuitState.OPEN

        # Try to call (should fail immediately without calling function)
        call_count = 0

        async def tracked_function():
            nonlocal call_count
            call_count += 1
            return "success"

        with pytest.raises(CircuitBreakerOpen):
            await circuit_breaker.call(tracked_function)

        # Function should not have been called
        assert call_count == 0

    @pytest.mark.asyncio
    async def test_open_circuit_error_message(self, circuit_breaker):
        """Test CircuitBreakerOpen error message."""
        async def failing_function():
            raise RuntimeError("Failure")

        # Open the circuit
        for _ in range(3):
            with pytest.raises(RuntimeError):
                await circuit_breaker.call(failing_function)

        # Try to call
        async def function():
            return "success"

        with pytest.raises(CircuitBreakerOpen) as exc_info:
            await circuit_breaker.call(function)

        assert "open" in str(exc_info.value).lower()


# ============================================================================
# Test Timeout Handling
# ============================================================================


class TestTimeoutHandling:
    """Test request timeout functionality."""

    @pytest.mark.asyncio
    async def test_timeout_raises_error(self, fast_circuit_breaker):
        """Test slow function raises timeout error."""
        async def slow_function():
            await asyncio.sleep(1.0)  # Longer than timeout
            return "success"

        with pytest.raises(CircuitBreakerTimeout):
            await fast_circuit_breaker.call(slow_function)

    @pytest.mark.asyncio
    async def test_timeout_counts_as_failure(self, fast_circuit_breaker):
        """Test timeout increments failure count."""
        async def slow_function():
            await asyncio.sleep(1.0)
            return "success"

        # Timeout once
        with pytest.raises(CircuitBreakerTimeout):
            await fast_circuit_breaker.call(slow_function)

        stats = fast_circuit_breaker.get_stats()
        assert stats["failure_count"] == 1

    @pytest.mark.asyncio
    async def test_timeout_can_open_circuit(self, fast_circuit_breaker):
        """Test timeouts can open circuit."""
        async def slow_function():
            await asyncio.sleep(1.0)
            return "success"

        # Timeout twice (threshold=2)
        for _ in range(2):
            with pytest.raises(CircuitBreakerTimeout):
                await fast_circuit_breaker.call(slow_function)

        # Circuit should be open
        assert fast_circuit_breaker.get_state() == CircuitState.OPEN

    @pytest.mark.asyncio
    async def test_fast_function_doesnt_timeout(self, circuit_breaker):
        """Test fast function completes without timeout."""
        async def fast_function():
            await asyncio.sleep(0.01)
            return "success"

        result = await circuit_breaker.call(fast_function)
        assert result == "success"


# ============================================================================
# Test Half-Open State
# ============================================================================


class TestHalfOpenState:
    """Test half-open state behavior."""

    @pytest.mark.asyncio
    async def test_half_open_allows_requests(self, fast_circuit_breaker):
        """Test half-open state allows test requests."""
        async def failing_function():
            raise RuntimeError("Failure")

        async def succeeding_function():
            return "success"

        # Open circuit
        for _ in range(2):
            with pytest.raises(RuntimeError):
                await fast_circuit_breaker.call(failing_function)

        # Wait for recovery
        await asyncio.sleep(0.15)

        # Should allow request in HALF_OPEN
        result = await fast_circuit_breaker.call(succeeding_function)
        assert result == "success"

    @pytest.mark.asyncio
    async def test_half_open_requires_success_threshold(self, circuit_breaker):
        """Test multiple successes required to close circuit."""
        # circuit_breaker has success_threshold=2
        async def failing_function():
            raise RuntimeError("Failure")

        async def succeeding_function():
            return "success"

        # Open circuit
        for _ in range(3):
            with pytest.raises(RuntimeError):
                await circuit_breaker.call(failing_function)

        # Wait for recovery
        await asyncio.sleep(1.1)

        # First success (should stay HALF_OPEN)
        await circuit_breaker.call(succeeding_function)
        assert circuit_breaker.get_state() == CircuitState.HALF_OPEN

        # Second success (should close)
        await circuit_breaker.call(succeeding_function)
        assert circuit_breaker.get_state() == CircuitState.CLOSED


# ============================================================================
# Test Statistics
# ============================================================================


class TestStatistics:
    """Test circuit breaker statistics."""

    @pytest.mark.asyncio
    async def test_initial_stats(self, circuit_breaker):
        """Test initial statistics."""
        stats = circuit_breaker.get_stats()

        assert stats["state"] == CircuitState.CLOSED.value
        assert stats["failure_count"] == 0
        assert stats["success_count"] == 0
        assert stats["failure_threshold"] == 3
        assert stats["success_threshold"] == 2

    @pytest.mark.asyncio
    async def test_stats_track_successes(self, circuit_breaker):
        """Test statistics track successful calls."""
        async def succeeding_function():
            return "success"

        for _ in range(5):
            await circuit_breaker.call(succeeding_function)

        stats = circuit_breaker.get_stats()
        assert stats["success_count"] == 5

    @pytest.mark.asyncio
    async def test_stats_track_failures(self, circuit_breaker):
        """Test statistics track failed calls."""
        async def failing_function():
            raise RuntimeError("Failure")

        for _ in range(2):  # Below threshold
            with pytest.raises(RuntimeError):
                await circuit_breaker.call(failing_function)

        stats = circuit_breaker.get_stats()
        assert stats["failure_count"] == 2

    @pytest.mark.asyncio
    async def test_stats_show_state_changes(self, circuit_breaker):
        """Test statistics reflect state changes."""
        async def failing_function():
            raise RuntimeError("Failure")

        # Open circuit
        for _ in range(3):
            with pytest.raises(RuntimeError):
                await circuit_breaker.call(failing_function)

        stats = circuit_breaker.get_stats()
        assert stats["state"] == CircuitState.OPEN.value


# ============================================================================
# Test Reset Functionality
# ============================================================================


class TestReset:
    """Test circuit breaker reset functionality."""

    @pytest.mark.asyncio
    async def test_reset_from_open_state(self, circuit_breaker):
        """Test resetting circuit breaker from OPEN state."""
        async def failing_function():
            raise RuntimeError("Failure")

        # Open circuit
        for _ in range(3):
            with pytest.raises(RuntimeError):
                await circuit_breaker.call(failing_function)

        assert circuit_breaker.get_state() == CircuitState.OPEN

        # Reset
        circuit_breaker.reset()

        assert circuit_breaker.get_state() == CircuitState.CLOSED
        stats = circuit_breaker.get_stats()
        assert stats["failure_count"] == 0
        assert stats["success_count"] == 0

    @pytest.mark.asyncio
    async def test_reset_from_half_open_state(self, fast_circuit_breaker):
        """Test resetting from HALF_OPEN state."""
        async def failing_function():
            raise RuntimeError("Failure")

        # Open circuit
        for _ in range(2):
            with pytest.raises(RuntimeError):
                await fast_circuit_breaker.call(failing_function)

        # Wait for recovery
        await asyncio.sleep(0.15)
        assert fast_circuit_breaker.get_state() == CircuitState.HALF_OPEN

        # Reset
        fast_circuit_breaker.reset()

        assert fast_circuit_breaker.get_state() == CircuitState.CLOSED


# ============================================================================
# Test Edge Cases
# ============================================================================


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    @pytest.mark.asyncio
    async def test_threshold_of_one(self):
        """Test circuit breaker with threshold of 1."""
        cb = CircuitBreaker(failure_threshold=1)

        async def failing_function():
            raise RuntimeError("Failure")

        # Single failure should open circuit
        with pytest.raises(RuntimeError):
            await cb.call(failing_function)

        assert cb.get_state() == CircuitState.OPEN

    @pytest.mark.asyncio
    async def test_zero_timeout_not_allowed(self):
        """Test circuit breaker doesn't allow zero timeout."""
        # This should work (positive timeout)
        cb = CircuitBreaker(timeout_seconds=0.1)
        assert cb.timeout_seconds == 0.1

    @pytest.mark.asyncio
    async def test_function_with_arguments(self, circuit_breaker):
        """Test calling function with arguments."""
        async def function_with_args(x, y, z=10):
            return x + y + z

        result = await circuit_breaker.call(function_with_args, 1, 2, z=3)
        assert result == 6

    @pytest.mark.asyncio
    async def test_function_with_kwargs(self, circuit_breaker):
        """Test calling function with keyword arguments."""
        async def function_with_kwargs(a=1, b=2, c=3):
            return a * b * c

        result = await circuit_breaker.call(function_with_kwargs, a=2, b=3, c=4)
        assert result == 24
