"""Tests for {{ capability_name }} Saga Pattern (SAP-046)

Tests verify saga execution, compensation, retries, timeouts,
and distributed transaction orchestration.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

import asyncio
from typing import Dict, Any

import pytest

from {{ package_name }}.infrastructure.composition import (
    Saga,
    SagaContext,
    SagaStep,
    SagaStatus,
    create_saga,
)


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def saga():
    """Create saga instance."""
    return create_saga()


@pytest.fixture
def execution_log():
    """Shared list to track execution order."""
    return []


# ============================================================================
# Test Saga Creation
# ============================================================================


class TestSagaCreation:
    """Test saga creation and step registration."""

    def test_create_saga(self):
        """Test creating a saga."""
        saga = create_saga()
        assert saga is not None
        assert saga.get_status()["status"] == SagaStatus.PENDING.value

    def test_add_step(self, saga):
        """Test adding a step to saga."""
        async def action(ctx: SagaContext):
            return {"success": True}

        saga.add_step(
            name="test-step",
            action=action
        )

        status = saga.get_status()
        assert "test-step" in status["steps"]

    def test_add_step_with_compensation(self, saga):
        """Test adding step with compensation."""
        async def action(ctx: SagaContext):
            return {"success": True}

        async def compensation(ctx: SagaContext):
            pass

        saga.add_step(
            name="test-step",
            action=action,
            compensation=compensation
        )

        # Should not raise exception
        assert True

    def test_add_multiple_steps(self, saga):
        """Test adding multiple steps."""
        async def action(ctx: SagaContext):
            return {"success": True}

        for i in range(5):
            saga.add_step(
                name=f"step-{i}",
                action=action
            )

        status = saga.get_status()
        assert len(status["steps"]) == 5


# ============================================================================
# Test Successful Execution
# ============================================================================


class TestSuccessfulExecution:
    """Test successful saga execution."""

    @pytest.mark.asyncio
    async def test_execute_empty_saga(self, saga):
        """Test executing saga with no steps."""
        result = await saga.execute()

        assert result["status"] == SagaStatus.COMPLETED.value
        assert result["completed_steps"] == []

    @pytest.mark.asyncio
    async def test_execute_single_step(self, saga, execution_log):
        """Test executing saga with single step."""
        async def action(ctx: SagaContext):
            execution_log.append("step-1")
            return {"data": "test"}

        saga.add_step(name="step-1", action=action)

        result = await saga.execute()

        assert result["status"] == SagaStatus.COMPLETED.value
        assert "step-1" in result["completed_steps"]
        assert "step-1" in execution_log

    @pytest.mark.asyncio
    async def test_execute_multiple_steps(self, saga, execution_log):
        """Test executing saga with multiple steps."""
        async def make_action(name: str):
            async def action(ctx: SagaContext):
                execution_log.append(name)
                return {"step": name}
            return action

        saga.add_step(name="step-1", action=await make_action("step-1"))
        saga.add_step(name="step-2", action=await make_action("step-2"))
        saga.add_step(name="step-3", action=await make_action("step-3"))

        result = await saga.execute()

        assert result["status"] == SagaStatus.COMPLETED.value
        assert result["completed_steps"] == ["step-1", "step-2", "step-3"]
        assert execution_log == ["step-1", "step-2", "step-3"]

    @pytest.mark.asyncio
    async def test_steps_execute_in_order(self, saga, execution_log):
        """Test steps execute in registration order."""
        async def make_action(name: str, delay: float):
            async def action(ctx: SagaContext):
                await asyncio.sleep(delay)
                execution_log.append(name)
                return {"step": name}
            return action

        # Add steps with varying delays (should still execute in order)
        saga.add_step(name="fast", action=await make_action("fast", 0.01))
        saga.add_step(name="slow", action=await make_action("slow", 0.05))
        saga.add_step(name="medium", action=await make_action("medium", 0.03))

        await saga.execute()

        # Should execute in registration order, not completion order
        assert execution_log == ["fast", "slow", "medium"]

    @pytest.mark.asyncio
    async def test_execute_duration_tracked(self, saga):
        """Test execution duration is tracked."""
        async def action(ctx: SagaContext):
            await asyncio.sleep(0.1)
            return {"success": True}

        saga.add_step(name="step", action=action)

        result = await saga.execute()

        assert result["duration_seconds"] >= 0.1


# ============================================================================
# Test Context Passing
# ============================================================================


class TestContextPassing:
    """Test context passing between steps."""

    @pytest.mark.asyncio
    async def test_context_shared_between_steps(self, saga):
        """Test steps can access shared context."""
        async def step1(ctx: SagaContext):
            ctx.data["value"] = 10
            return {"set": True}

        async def step2(ctx: SagaContext):
            ctx.data["value"] += 5
            return {"incremented": True}

        async def step3(ctx: SagaContext):
            return {"final_value": ctx.data["value"]}

        saga.add_step(name="step1", action=step1)
        saga.add_step(name="step2", action=step2)
        saga.add_step(name="step3", action=step3)

        result = await saga.execute()

        assert result["data"]["value"] == 15

    @pytest.mark.asyncio
    async def test_context_with_initial_data(self, saga):
        """Test executing saga with initial context data."""
        async def action(ctx: SagaContext):
            return {"received": ctx.data.get("initial_value")}

        saga.add_step(name="step", action=action)

        context = SagaContext(data={"initial_value": 42})
        result = await saga.execute(context)

        assert result["data"]["initial_value"] == 42

    @pytest.mark.asyncio
    async def test_step_results_stored_in_context(self, saga):
        """Test step results are stored in context."""
        async def step1(ctx: SagaContext):
            return {"result": "step1"}

        async def step2(ctx: SagaContext):
            return {"result": "step2"}

        saga.add_step(name="step1", action=step1)
        saga.add_step(name="step2", action=step2)

        context = SagaContext()
        await saga.execute(context)

        assert len(context.step_results) == 2
        assert context.step_results[0]["step"] == "step1"
        assert context.step_results[0]["result"]["result"] == "step1"


# ============================================================================
# Test Failure and Compensation
# ============================================================================


class TestFailureAndCompensation:
    """Test failure handling and compensation."""

    @pytest.mark.asyncio
    async def test_failure_triggers_compensation(self, saga, execution_log):
        """Test step failure triggers compensation."""
        async def step1_action(ctx: SagaContext):
            execution_log.append("step1-action")
            return {"success": True}

        async def step1_compensation(ctx: SagaContext):
            execution_log.append("step1-compensation")

        async def step2_action(ctx: SagaContext):
            execution_log.append("step2-action")
            raise RuntimeError("Step 2 failed")

        saga.add_step(
            name="step1",
            action=step1_action,
            compensation=step1_compensation
        )
        saga.add_step(
            name="step2",
            action=step2_action
        )

        result = await saga.execute()

        assert result["status"] == SagaStatus.COMPENSATED.value
        assert "step1-action" in execution_log
        assert "step2-action" in execution_log
        assert "step1-compensation" in execution_log

    @pytest.mark.asyncio
    async def test_compensation_in_reverse_order(self, saga, execution_log):
        """Test compensation executes in reverse order."""
        async def make_action(name: str):
            async def action(ctx: SagaContext):
                execution_log.append(f"{name}-action")
                return {"success": True}
            return action

        async def make_compensation(name: str):
            async def compensation(ctx: SagaContext):
                execution_log.append(f"{name}-compensation")
            return compensation

        async def failing_action(ctx: SagaContext):
            execution_log.append("failing-action")
            raise RuntimeError("Failure")

        saga.add_step(
            name="step1",
            action=await make_action("step1"),
            compensation=await make_compensation("step1")
        )
        saga.add_step(
            name="step2",
            action=await make_action("step2"),
            compensation=await make_compensation("step2")
        )
        saga.add_step(
            name="step3",
            action=await make_action("step3"),
            compensation=await make_compensation("step3")
        )
        saga.add_step(
            name="failing",
            action=failing_action
        )

        await saga.execute()

        # Compensation should be in reverse: step3, step2, step1
        compensation_log = [log for log in execution_log if "compensation" in log]
        assert compensation_log == [
            "step3-compensation",
            "step2-compensation",
            "step1-compensation"
        ]

    @pytest.mark.asyncio
    async def test_step_without_compensation(self, saga, execution_log):
        """Test compensation skips steps without compensation function."""
        async def step1_action(ctx: SagaContext):
            execution_log.append("step1-action")
            return {"success": True}

        async def step2_action(ctx: SagaContext):
            execution_log.append("step2-action")
            return {"success": True}

        async def step2_compensation(ctx: SagaContext):
            execution_log.append("step2-compensation")

        async def failing_action(ctx: SagaContext):
            raise RuntimeError("Failure")

        saga.add_step(
            name="step1",
            action=step1_action
            # No compensation
        )
        saga.add_step(
            name="step2",
            action=step2_action,
            compensation=step2_compensation
        )
        saga.add_step(
            name="failing",
            action=failing_action
        )

        await saga.execute()

        # Only step2 has compensation
        assert "step2-compensation" in execution_log
        assert "step1-compensation" not in execution_log

    @pytest.mark.asyncio
    async def test_compensation_failure(self, saga):
        """Test compensation failure changes status to FAILED."""
        async def action(ctx: SagaContext):
            return {"success": True}

        async def failing_compensation(ctx: SagaContext):
            raise RuntimeError("Compensation failed")

        async def failing_action(ctx: SagaContext):
            raise RuntimeError("Action failed")

        saga.add_step(
            name="step1",
            action=action,
            compensation=failing_compensation
        )
        saga.add_step(
            name="step2",
            action=failing_action
        )

        result = await saga.execute()

        assert result["status"] == SagaStatus.FAILED.value
        assert "compensation failed" in result["error"].lower()


# ============================================================================
# Test Retry Logic
# ============================================================================


class TestRetryLogic:
    """Test step retry functionality."""

    @pytest.mark.asyncio
    async def test_retry_on_failure(self, saga, execution_log):
        """Test step retries on failure."""
        attempt_count = 0

        async def action_with_retry(ctx: SagaContext):
            nonlocal attempt_count
            attempt_count += 1
            execution_log.append(f"attempt-{attempt_count}")

            if attempt_count < 3:
                raise RuntimeError("Retry")
            return {"success": True}

        saga.add_step(
            name="step",
            action=action_with_retry,
            retries=2  # Will try 3 times total (initial + 2 retries)
        )

        result = await saga.execute()

        assert result["status"] == SagaStatus.COMPLETED.value
        assert attempt_count == 3
        assert len(execution_log) == 3

    @pytest.mark.asyncio
    async def test_retry_exhaustion(self, saga):
        """Test step fails after exhausting retries."""
        attempt_count = 0

        async def always_failing_action(ctx: SagaContext):
            nonlocal attempt_count
            attempt_count += 1
            raise RuntimeError("Always fails")

        saga.add_step(
            name="step",
            action=always_failing_action,
            retries=2
        )

        result = await saga.execute()

        assert result["status"] == SagaStatus.COMPENSATED.value
        assert attempt_count == 3  # Initial + 2 retries


# ============================================================================
# Test Timeout Handling
# ============================================================================


class TestTimeoutHandling:
    """Test step timeout functionality."""

    @pytest.mark.asyncio
    async def test_step_timeout(self, saga):
        """Test step timeout triggers failure."""
        async def slow_action(ctx: SagaContext):
            await asyncio.sleep(2.0)
            return {"success": True}

        saga.add_step(
            name="slow-step",
            action=slow_action,
            timeout_seconds=0.1
        )

        result = await saga.execute()

        assert result["status"] == SagaStatus.COMPENSATED.value
        assert "timed out" in result["error"].lower()

    @pytest.mark.asyncio
    async def test_fast_step_doesnt_timeout(self, saga):
        """Test fast step completes without timeout."""
        async def fast_action(ctx: SagaContext):
            await asyncio.sleep(0.01)
            return {"success": True}

        saga.add_step(
            name="fast-step",
            action=fast_action,
            timeout_seconds=1.0
        )

        result = await saga.execute()

        assert result["status"] == SagaStatus.COMPLETED.value

    @pytest.mark.asyncio
    async def test_compensation_timeout(self, saga):
        """Test compensation also respects timeout."""
        async def action(ctx: SagaContext):
            return {"success": True}

        async def slow_compensation(ctx: SagaContext):
            await asyncio.sleep(2.0)

        async def failing_action(ctx: SagaContext):
            raise RuntimeError("Failure")

        saga.add_step(
            name="step",
            action=action,
            compensation=slow_compensation,
            timeout_seconds=0.1
        )
        saga.add_step(
            name="failing",
            action=failing_action
        )

        result = await saga.execute()

        assert result["status"] == SagaStatus.FAILED.value
        assert "compensation" in result["error"].lower()


# ============================================================================
# Test Saga Status
# ============================================================================


class TestSagaStatus:
    """Test saga status tracking."""

    def test_initial_status(self, saga):
        """Test initial saga status."""
        status = saga.get_status()

        assert status["status"] == SagaStatus.PENDING.value
        assert status["steps"] == []
        assert status["completed_steps"] == []
        assert status["failed_step"] is None

    @pytest.mark.asyncio
    async def test_status_during_execution(self, saga):
        """Test saga status changes during execution."""
        # This test is tricky because execution is fast
        # We'll just verify final status
        async def action(ctx: SagaContext):
            return {"success": True}

        saga.add_step(name="step", action=action)

        await saga.execute()

        status = saga.get_status()
        assert status["status"] == SagaStatus.COMPLETED.value

    @pytest.mark.asyncio
    async def test_status_on_failure(self, saga):
        """Test status after failure and compensation."""
        async def action(ctx: SagaContext):
            return {"success": True}

        async def compensation(ctx: SagaContext):
            pass

        async def failing_action(ctx: SagaContext):
            raise RuntimeError("Failure")

        saga.add_step(
            name="step1",
            action=action,
            compensation=compensation
        )
        saga.add_step(
            name="failing",
            action=failing_action
        )

        await saga.execute()

        status = saga.get_status()
        assert status["status"] == SagaStatus.COMPENSATED.value
        assert "step1" in status["completed_steps"]


# ============================================================================
# Test SagaContext Model
# ============================================================================


class TestSagaContextModel:
    """Test SagaContext model."""

    def test_context_creation(self):
        """Test creating saga context."""
        context = SagaContext()

        assert context.data == {}
        assert context.metadata == {}
        assert context.step_results == []
        assert len(str(context.saga_id)) > 0

    def test_context_with_initial_data(self):
        """Test creating context with initial data."""
        context = SagaContext(
            data={"key": "value"},
            metadata={"user": "test"}
        )

        assert context.data["key"] == "value"
        assert context.metadata["user"] == "test"

    def test_context_saga_id_unique(self):
        """Test each context has unique saga_id."""
        ctx1 = SagaContext()
        ctx2 = SagaContext()

        assert ctx1.saga_id != ctx2.saga_id


# ============================================================================
# Test SagaStep Model
# ============================================================================


class TestSagaStepModel:
    """Test SagaStep model."""

    def test_step_defaults(self):
        """Test default step values."""
        async def action(ctx: SagaContext):
            return {"success": True}

        step = SagaStep(name="test", action=action)

        assert step.compensation is None
        assert step.timeout_seconds == 30
        assert step.retries == 0

    def test_step_custom_values(self):
        """Test custom step values."""
        async def action(ctx: SagaContext):
            return {"success": True}

        async def compensation(ctx: SagaContext):
            pass

        step = SagaStep(
            name="test",
            action=action,
            compensation=compensation,
            timeout_seconds=60,
            retries=3
        )

        assert step.compensation is not None
        assert step.timeout_seconds == 60
        assert step.retries == 3


# ============================================================================
# Test Example Saga
# ============================================================================


class TestExampleSaga:
    """Test example entity creation saga."""

    @pytest.mark.asyncio
    async def test_example_entity_creation_saga(self):
        """Test complete example saga workflow."""
        from {{ package_name }}.infrastructure.composition import create_entity_saga

        result = await create_entity_saga(
            entity_data={"name": "Test Entity"}
        )

        assert result["status"] == SagaStatus.COMPLETED.value
        assert len(result["completed_steps"]) == 3  # validate, reserve_resources, create_entity


# ============================================================================
# Test Edge Cases
# ============================================================================


class TestEdgeCases:
    """Test edge cases and boundary conditions."""

    @pytest.mark.asyncio
    async def test_execute_saga_twice(self, saga):
        """Test executing saga multiple times."""
        async def action(ctx: SagaContext):
            return {"success": True}

        saga.add_step(name="step", action=action)

        # First execution
        result1 = await saga.execute()
        assert result1["status"] == SagaStatus.COMPLETED.value

        # Second execution (should work)
        result2 = await saga.execute()
        assert result2["status"] == SagaStatus.COMPLETED.value

    @pytest.mark.asyncio
    async def test_saga_with_no_data(self, saga):
        """Test saga execution with no context data."""
        async def action(ctx: SagaContext):
            # Access empty data
            assert ctx.data == {}
            return {"success": True}

        saga.add_step(name="step", action=action)

        result = await saga.execute()
        assert result["status"] == SagaStatus.COMPLETED.value

    @pytest.mark.asyncio
    async def test_first_step_failure(self, saga, execution_log):
        """Test failure on first step (no compensation needed)."""
        async def failing_action(ctx: SagaContext):
            execution_log.append("failing-action")
            raise RuntimeError("Immediate failure")

        async def never_called_compensation(ctx: SagaContext):
            execution_log.append("compensation-called")

        saga.add_step(
            name="failing",
            action=failing_action,
            compensation=never_called_compensation
        )

        result = await saga.execute()

        assert result["status"] == SagaStatus.COMPENSATED.value
        assert "failing-action" in execution_log
        # No compensation should be called for failed step itself
        assert "compensation-called" not in execution_log
