"""Tests for {{ capability_name }} Bootstrap Orchestrator (SAP-045)

Tests verify dependency resolution, startup ordering, timeout handling,
rollback on failure, and health checks.

Generated by: chora-base SAP-047 (Capability Server Template)
"""

import asyncio
from typing import List

import pytest

from {{ package_name }}.infrastructure.bootstrap import (
    Bootstrap,
    BootstrapPhase,
    BootstrapResult,
    Component,
)


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def bootstrap():
    """Create bootstrap orchestrator."""
    return Bootstrap()


@pytest.fixture
def startup_log():
    """Shared list to track startup order."""
    return []


# ============================================================================
# Test Component Registration
# ============================================================================


class TestComponentRegistration:
    """Test component registration."""

    def test_register_component(self, bootstrap):
        """Test registering a component."""
        async def startup():
            pass

        component = Component(
            name="test-component",
            dependencies=[],
            startup_fn=startup
        )

        bootstrap.register_component(component)

        # Should not raise exception
        assert True

    def test_register_duplicate_component(self, bootstrap):
        """Test registering duplicate component raises ValueError."""
        async def startup():
            pass

        component = Component(
            name="duplicate",
            dependencies=[],
            startup_fn=startup
        )

        bootstrap.register_component(component)

        # Try to register again
        with pytest.raises(ValueError) as exc_info:
            bootstrap.register_component(component)

        assert "already registered" in str(exc_info.value)

    def test_register_multiple_components(self, bootstrap):
        """Test registering multiple components."""
        async def startup():
            pass

        for i in range(3):
            component = Component(
                name=f"component-{i}",
                dependencies=[],
                startup_fn=startup
            )
            bootstrap.register_component(component)

        # All should be registered
        assert True


# ============================================================================
# Test Dependency Resolution
# ============================================================================


class TestDependencyResolution:
    """Test dependency resolution and startup order."""

    @pytest.mark.asyncio
    async def test_simple_dependency_chain(self, bootstrap, startup_log):
        """Test resolving simple dependency chain: A -> B -> C."""
        async def make_startup_fn(name: str):
            """Create startup function that logs to startup_log."""
            async def startup():
                startup_log.append(name)
            return startup

        # Register components
        # C depends on B, B depends on A, A has no deps
        bootstrap.register_component(Component(
            name="A",
            dependencies=[],
            startup_fn=await make_startup_fn("A")
        ))
        bootstrap.register_component(Component(
            name="B",
            dependencies=["A"],
            startup_fn=await make_startup_fn("B")
        ))
        bootstrap.register_component(Component(
            name="C",
            dependencies=["B"],
            startup_fn=await make_startup_fn("C")
        ))

        result = await bootstrap.start()

        assert result.success is True
        assert startup_log == ["A", "B", "C"]

    @pytest.mark.asyncio
    async def test_parallel_dependencies(self, bootstrap, startup_log):
        """Test resolving parallel dependencies: A, B both depend on C."""
        async def make_startup_fn(name: str):
            async def startup():
                startup_log.append(name)
            return startup

        # C has no deps, A and B both depend on C
        bootstrap.register_component(Component(
            name="C",
            dependencies=[],
            startup_fn=await make_startup_fn("C")
        ))
        bootstrap.register_component(Component(
            name="A",
            dependencies=["C"],
            startup_fn=await make_startup_fn("A")
        ))
        bootstrap.register_component(Component(
            name="B",
            dependencies=["C"],
            startup_fn=await make_startup_fn("B")
        ))

        result = await bootstrap.start()

        assert result.success is True
        # C must start first, then A and B (order between A and B doesn't matter)
        assert startup_log[0] == "C"
        assert set(startup_log[1:]) == {"A", "B"}

    @pytest.mark.asyncio
    async def test_complex_dependency_graph(self, bootstrap, startup_log):
        """Test complex dependency graph."""
        async def make_startup_fn(name: str):
            async def startup():
                startup_log.append(name)
            return startup

        # Build graph:
        #     D
        #    / \
        #   B   C
        #    \ /
        #     A
        bootstrap.register_component(Component(
            name="A",
            dependencies=[],
            startup_fn=await make_startup_fn("A")
        ))
        bootstrap.register_component(Component(
            name="B",
            dependencies=["A"],
            startup_fn=await make_startup_fn("B")
        ))
        bootstrap.register_component(Component(
            name="C",
            dependencies=["A"],
            startup_fn=await make_startup_fn("C")
        ))
        bootstrap.register_component(Component(
            name="D",
            dependencies=["B", "C"],
            startup_fn=await make_startup_fn("D")
        ))

        result = await bootstrap.start()

        assert result.success is True
        # A must be first, D must be last
        assert startup_log[0] == "A"
        assert startup_log[3] == "D"
        # B and C can be in any order
        assert set(startup_log[1:3]) == {"B", "C"}

    @pytest.mark.asyncio
    async def test_circular_dependency_detection(self, bootstrap):
        """Test circular dependency raises ValueError."""
        async def startup():
            pass

        # Create circular dependency: A -> B -> C -> A
        bootstrap.register_component(Component(
            name="A",
            dependencies=["C"],
            startup_fn=startup
        ))
        bootstrap.register_component(Component(
            name="B",
            dependencies=["A"],
            startup_fn=startup
        ))
        bootstrap.register_component(Component(
            name="C",
            dependencies=["B"],
            startup_fn=startup
        ))

        with pytest.raises(ValueError) as exc_info:
            await bootstrap.start()

        assert "circular dependency" in str(exc_info.value).lower()

    @pytest.mark.asyncio
    async def test_missing_dependency(self, bootstrap):
        """Test missing dependency raises ValueError."""
        async def startup():
            pass

        bootstrap.register_component(Component(
            name="A",
            dependencies=["nonexistent"],
            startup_fn=startup
        ))

        with pytest.raises(ValueError) as exc_info:
            await bootstrap.start()

        assert "unknown component" in str(exc_info.value).lower()


# ============================================================================
# Test Startup Success
# ============================================================================


class TestStartupSuccess:
    """Test successful startup scenarios."""

    @pytest.mark.asyncio
    async def test_start_no_components(self, bootstrap):
        """Test starting with no components succeeds."""
        result = await bootstrap.start()

        assert result.success is True
        assert result.phase == BootstrapPhase.READY
        assert result.started_components == []

    @pytest.mark.asyncio
    async def test_start_single_component(self, bootstrap):
        """Test starting single component."""
        started = []

        async def startup():
            started.append("component")

        bootstrap.register_component(Component(
            name="component",
            dependencies=[],
            startup_fn=startup
        ))

        result = await bootstrap.start()

        assert result.success is True
        assert result.phase == BootstrapPhase.READY
        assert "component" in result.started_components
        assert started == ["component"]

    @pytest.mark.asyncio
    async def test_start_multiple_components(self, bootstrap):
        """Test starting multiple independent components."""
        started = []

        async def make_startup_fn(name: str):
            async def startup():
                started.append(name)
            return startup

        for i in range(3):
            bootstrap.register_component(Component(
                name=f"component-{i}",
                dependencies=[],
                startup_fn=await make_startup_fn(f"component-{i}")
            ))

        result = await bootstrap.start()

        assert result.success is True
        assert len(result.started_components) == 3
        assert len(started) == 3

    @pytest.mark.asyncio
    async def test_start_duration_tracked(self, bootstrap):
        """Test startup duration is tracked."""
        async def startup():
            await asyncio.sleep(0.1)

        bootstrap.register_component(Component(
            name="component",
            dependencies=[],
            startup_fn=startup
        ))

        result = await bootstrap.start()

        assert result.duration_seconds >= 0.1


# ============================================================================
# Test Startup Failure
# ============================================================================


class TestStartupFailure:
    """Test startup failure and rollback scenarios."""

    @pytest.mark.asyncio
    async def test_critical_component_failure(self, bootstrap):
        """Test critical component failure triggers rollback."""
        started = []
        stopped = []

        async def startup_success():
            started.append("success")

        async def startup_failure():
            started.append("failure-attempted")
            raise RuntimeError("Startup failed")

        async def shutdown():
            stopped.append("success")

        # Register successful component
        bootstrap.register_component(Component(
            name="success",
            dependencies=[],
            startup_fn=startup_success,
            shutdown_fn=shutdown,
            critical=True
        ))

        # Register failing component (depends on success)
        bootstrap.register_component(Component(
            name="failure",
            dependencies=["success"],
            startup_fn=startup_failure,
            critical=True
        ))

        result = await bootstrap.start()

        assert result.success is False
        assert result.phase == BootstrapPhase.FAILED
        assert "failure" in result.failed_components
        # Rollback should have stopped the successful component
        assert "success" in stopped

    @pytest.mark.asyncio
    async def test_non_critical_component_failure(self, bootstrap):
        """Test non-critical component failure doesn't stop startup."""
        started = []

        async def startup_success():
            started.append("success")

        async def startup_failure():
            raise RuntimeError("Non-critical failure")

        # Critical component
        bootstrap.register_component(Component(
            name="critical",
            dependencies=[],
            startup_fn=startup_success,
            critical=True
        ))

        # Non-critical component
        bootstrap.register_component(Component(
            name="non-critical",
            dependencies=[],
            startup_fn=startup_failure,
            critical=False
        ))

        result = await bootstrap.start()

        # Should succeed despite non-critical failure
        assert result.success is True
        assert result.phase == BootstrapPhase.READY
        assert "critical" in result.started_components
        assert "non-critical" not in result.started_components
        assert "non-critical" in result.failed_components

    @pytest.mark.asyncio
    async def test_timeout_handling(self, bootstrap):
        """Test component startup timeout."""
        async def slow_startup():
            await asyncio.sleep(2.0)  # Longer than timeout

        bootstrap.register_component(Component(
            name="slow",
            dependencies=[],
            startup_fn=slow_startup,
            timeout_seconds=0.1,  # Very short timeout
            critical=True
        ))

        result = await bootstrap.start()

        assert result.success is False
        assert "slow" in result.failed_components

    @pytest.mark.asyncio
    async def test_rollback_order(self, bootstrap):
        """Test rollback stops components in reverse order."""
        stopped = []

        async def make_startup_fn(name: str):
            async def startup():
                pass
            return startup

        async def make_shutdown_fn(name: str):
            async def shutdown():
                stopped.append(name)
            return shutdown

        async def startup_failure():
            raise RuntimeError("Failure")

        # Register chain: A -> B -> C -> failure
        bootstrap.register_component(Component(
            name="A",
            dependencies=[],
            startup_fn=await make_startup_fn("A"),
            shutdown_fn=await make_shutdown_fn("A")
        ))
        bootstrap.register_component(Component(
            name="B",
            dependencies=["A"],
            startup_fn=await make_startup_fn("B"),
            shutdown_fn=await make_shutdown_fn("B")
        ))
        bootstrap.register_component(Component(
            name="C",
            dependencies=["B"],
            startup_fn=await make_startup_fn("C"),
            shutdown_fn=await make_shutdown_fn("C")
        ))
        bootstrap.register_component(Component(
            name="failure",
            dependencies=["C"],
            startup_fn=startup_failure,
            critical=True
        ))

        result = await bootstrap.start()

        assert result.success is False
        # Should stop in reverse order: C, B, A
        assert stopped == ["C", "B", "A"]


# ============================================================================
# Test Shutdown
# ============================================================================


class TestShutdown:
    """Test shutdown functionality."""

    @pytest.mark.asyncio
    async def test_stop_after_successful_start(self, bootstrap):
        """Test stopping after successful start."""
        stopped = []

        async def startup():
            pass

        async def make_shutdown_fn(name: str):
            async def shutdown():
                stopped.append(name)
            return shutdown

        # Register components
        for i in range(3):
            bootstrap.register_component(Component(
                name=f"component-{i}",
                dependencies=[],
                startup_fn=startup,
                shutdown_fn=await make_shutdown_fn(f"component-{i}")
            ))

        # Start
        start_result = await bootstrap.start()
        assert start_result.success is True

        # Stop
        stop_result = await bootstrap.stop()

        assert stop_result.success is True
        assert stop_result.phase == BootstrapPhase.STOPPED
        assert len(stopped) == 3

    @pytest.mark.asyncio
    async def test_stop_reverses_startup_order(self, bootstrap):
        """Test shutdown reverses startup order."""
        started = []
        stopped = []

        async def make_startup_fn(name: str):
            async def startup():
                started.append(name)
            return startup

        async def make_shutdown_fn(name: str):
            async def shutdown():
                stopped.append(name)
            return shutdown

        # Register chain: A -> B -> C
        bootstrap.register_component(Component(
            name="A",
            dependencies=[],
            startup_fn=await make_startup_fn("A"),
            shutdown_fn=await make_shutdown_fn("A")
        ))
        bootstrap.register_component(Component(
            name="B",
            dependencies=["A"],
            startup_fn=await make_startup_fn("B"),
            shutdown_fn=await make_shutdown_fn("B")
        ))
        bootstrap.register_component(Component(
            name="C",
            dependencies=["B"],
            startup_fn=await make_startup_fn("C"),
            shutdown_fn=await make_shutdown_fn("C")
        ))

        await bootstrap.start()
        await bootstrap.stop()

        # Started: A, B, C
        assert started == ["A", "B", "C"]
        # Stopped: C, B, A (reverse)
        assert stopped == ["C", "B", "A"]

    @pytest.mark.asyncio
    async def test_stop_handles_shutdown_failures(self, bootstrap):
        """Test shutdown continues despite component failures."""
        stopped = []

        async def startup():
            pass

        async def shutdown_success():
            stopped.append("success")

        async def shutdown_failure():
            raise RuntimeError("Shutdown failed")

        bootstrap.register_component(Component(
            name="success",
            dependencies=[],
            startup_fn=startup,
            shutdown_fn=shutdown_success
        ))
        bootstrap.register_component(Component(
            name="failure",
            dependencies=[],
            startup_fn=startup,
            shutdown_fn=shutdown_failure
        ))

        await bootstrap.start()
        result = await bootstrap.stop()

        # Should report failure but continue
        assert result.success is False
        assert "failure" in result.failed_components
        # Success component should still be stopped
        assert "success" in stopped

    @pytest.mark.asyncio
    async def test_cannot_stop_before_start(self, bootstrap):
        """Test stopping before starting raises error."""
        async def startup():
            pass

        bootstrap.register_component(Component(
            name="component",
            dependencies=[],
            startup_fn=startup
        ))

        with pytest.raises(RuntimeError) as exc_info:
            await bootstrap.stop()

        assert "cannot stop" in str(exc_info.value).lower()


# ============================================================================
# Test Health Checks
# ============================================================================


class TestHealthChecks:
    """Test health check functionality."""

    @pytest.mark.asyncio
    async def test_health_check_all_healthy(self, bootstrap):
        """Test health check with all healthy components."""
        async def startup():
            pass

        async def health_check():
            return {"status": "ok"}

        for i in range(3):
            bootstrap.register_component(Component(
                name=f"component-{i}",
                dependencies=[],
                startup_fn=startup,
                health_check_fn=health_check
            ))

        await bootstrap.start()
        health = await bootstrap.health_check()

        assert health["phase"] == BootstrapPhase.READY.value
        assert len(health["components"]) == 3
        for component_health in health["components"].values():
            assert component_health["status"] == "healthy"

    @pytest.mark.asyncio
    async def test_health_check_unhealthy_component(self, bootstrap):
        """Test health check detects unhealthy component."""
        async def startup():
            pass

        async def health_check_healthy():
            return {"status": "ok"}

        async def health_check_unhealthy():
            raise RuntimeError("Component unhealthy")

        bootstrap.register_component(Component(
            name="healthy",
            dependencies=[],
            startup_fn=startup,
            health_check_fn=health_check_healthy
        ))
        bootstrap.register_component(Component(
            name="unhealthy",
            dependencies=[],
            startup_fn=startup,
            health_check_fn=health_check_unhealthy
        ))

        await bootstrap.start()
        health = await bootstrap.health_check()

        assert health["components"]["healthy"]["status"] == "healthy"
        assert health["components"]["unhealthy"]["status"] == "unhealthy"

    @pytest.mark.asyncio
    async def test_health_check_no_health_check_defined(self, bootstrap):
        """Test health check for component without health check function."""
        async def startup():
            pass

        bootstrap.register_component(Component(
            name="component",
            dependencies=[],
            startup_fn=startup
            # No health_check_fn
        ))

        await bootstrap.start()
        health = await bootstrap.health_check()

        assert health["components"]["component"]["status"] == "unknown"


# ============================================================================
# Test Component Model
# ============================================================================


class TestComponentModel:
    """Test Component model."""

    def test_component_defaults(self):
        """Test default component values."""
        async def startup():
            pass

        component = Component(
            name="test",
            startup_fn=startup
        )

        assert component.dependencies == []
        assert component.shutdown_fn is None
        assert component.health_check_fn is None
        assert component.timeout_seconds == 30
        assert component.critical is True

    def test_component_custom_values(self):
        """Test custom component values."""
        async def startup():
            pass

        async def shutdown():
            pass

        component = Component(
            name="test",
            dependencies=["dep1", "dep2"],
            startup_fn=startup,
            shutdown_fn=shutdown,
            timeout_seconds=60,
            critical=False
        )

        assert component.dependencies == ["dep1", "dep2"]
        assert component.shutdown_fn is not None
        assert component.timeout_seconds == 60
        assert component.critical is False
