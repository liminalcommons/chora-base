"""Tests for {{ capability_name }} MCP Interface (SAP-043)

Tests verify MCP tools, resources, and error handling.

Generated by: chora-base SAP-047 (Capability Server Template)

Note: This test file is only included when --enable-mcp flag is used.
"""

from uuid import uuid4

import pytest

from {{ package_name }}.interfaces.mcp import mcp, ToolExecutor
from {{ package_name }}.core import {{ capability_name_pascal }}Status, create_{{ capability_name_snake }}_service


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture
def service():
    """Create shared service instance for MCP tests.

    This service is injected into ToolExecutor to ensure entities persist
    across multiple tool calls within the same test.
    """
    return create_{{ capability_name_snake }}_service()


@pytest.fixture
def executor(service):
    """Create ToolExecutor with shared service instance.

    The executor is used by tests to call tool functions directly while
    maintaining service state across multiple calls.
    """
    return ToolExecutor(service)


@pytest.fixture
def mcp_server():
    """Get MCP server instance for registration tests."""
    return mcp


# ============================================================================
# Test Tool Registration
# ============================================================================


class TestToolRegistration:
    """Test MCP tools are properly registered."""

    @pytest.mark.asyncio
    async def test_tools_registered(self, mcp_server):
        """Test all expected tools are registered."""
        tool_names = [tool.name for tool in await mcp_server.list_tools()]

        expected_tools = [
            "{{ namespace }}:create",
            "{{ namespace }}:get",
            "{{ namespace }}:list",
            "{{ namespace }}:update",
            "{{ namespace }}:delete",
            "{{ namespace }}:update_status",
            "{{ namespace }}:health",
        ]

        for expected in expected_tools:
            assert expected in tool_names, f"Tool {expected} not registered"


# ============================================================================
# Test Create Tool
# ============================================================================


class TestCreateTool:
    """Test {{ namespace }}:create tool."""

    @pytest.mark.asyncio
    async def test_create_basic(self, executor):
        """Test creating an entity."""
        result = await executor.create_entity(name="Test Entity")

        assert result["success"] is True
        assert result["entity"]["name"] == "Test Entity"
        assert "id" in result["entity"]

    @pytest.mark.asyncio
    async def test_create_with_all_fields(self, executor):
        """Test creating entity with all fields."""
        result = await executor.create_entity(
            name="Test Entity",
            description="Test description",
            metadata={"key": "value"}
        )

        assert result["success"] is True
        assert result["entity"]["description"] == "Test description"
        assert result["entity"]["metadata"]["key"] == "value"

    @pytest.mark.asyncio
    async def test_create_invalid_name(self, executor):
        """Test create with invalid name."""
        result = await executor.create_entity(name="")

        assert result["success"] is False
        assert "error" in result


# ============================================================================
# Test Get Tool
# ============================================================================


class TestGetTool:
    """Test {{ namespace }}:get tool."""

    @pytest.mark.asyncio
    async def test_get_existing_entity(self, executor):
        """Test getting an existing entity."""
        # Create entity
        create_result = await executor.create_entity(name="Test Entity")
        entity_id = create_result["entity"]["id"]

        # Get entity
        result = await executor.get_entity(entity_id=entity_id)

        assert result["success"] is True
        assert result["entity"]["id"] == entity_id

    @pytest.mark.asyncio
    async def test_get_nonexistent_entity(self, executor):
        """Test getting non-existent entity."""
        fake_id = str(uuid4())
        result = await executor.get_entity(entity_id=fake_id)

        assert result["success"] is False
        assert result["error"] == "NOT_FOUND"

    @pytest.mark.asyncio
    async def test_get_invalid_uuid(self, executor):
        """Test get with invalid UUID."""
        result = await executor.get_entity(entity_id="not-a-uuid")

        assert result["success"] is False
        assert result["error"] == "INVALID_UUID"


# ============================================================================
# Test List Tool
# ============================================================================


class TestListTool:
    """Test {{ namespace }}:list tool."""

    @pytest.mark.asyncio
    async def test_list_empty(self, executor):
        """Test listing when no entities exist."""
        result = await executor.list_entities()

        assert result["success"] is True
        assert result["entities"] == []
        assert result["total"] == 0

    @pytest.mark.asyncio
    async def test_list_with_entities(self, executor):
        """Test listing with existing entities."""
        # Create some entities
        for i in range(3):
            await executor.create_entity(name=f"Entity {i}")

        # List all
        result = await executor.list_entities()

        assert result["success"] is True
        assert len(result["entities"]) == 3
        assert result["total"] == 3

    @pytest.mark.asyncio
    async def test_list_with_status_filter(self, executor):
        """Test listing with status filter."""
        # Create entity and update status
        create_result = await executor.create_entity(name="Test Entity")
        entity_id = create_result["entity"]["id"]

        await executor.update_status(entity_id=entity_id, new_status="active")

        # List active entities
        result = await executor.list_entities(status="active")

        assert result["success"] is True
        assert all(e["status"] == "active" for e in result["entities"])

    @pytest.mark.asyncio
    async def test_list_with_name_filter(self, executor):
        """Test listing with name filter."""
        # Create entities
        await executor.create_entity(name="Alpha")
        await executor.create_entity(name="Beta")
        await executor.create_entity(name="Alphabet")

        # Filter by name
        result = await executor.list_entities(name_contains="alpha")

        assert result["success"] is True
        assert result["total"] == 2

    @pytest.mark.asyncio
    async def test_list_with_pagination(self, executor):
        """Test pagination."""
        # Create 10 entities
        for i in range(10):
            await executor.create_entity(name=f"Entity {i}")

        # Get first page
        result = await executor.list_entities(offset=0, limit=5)

        assert result["success"] is True
        assert len(result["entities"]) == 5
        assert result["total"] == 10

    @pytest.mark.asyncio
    async def test_list_invalid_status(self, executor):
        """Test list with invalid status."""
        result = await executor.list_entities(status="invalid-status")

        assert result["success"] is False
        assert result["error"] == "INVALID_STATUS"


# ============================================================================
# Test Update Tool
# ============================================================================


class TestUpdateTool:
    """Test {{ namespace }}:update tool."""

    @pytest.mark.asyncio
    async def test_update_entity(self, executor):
        """Test updating an entity."""
        # Create entity
        create_result = await executor.create_entity(name="Original Name")
        entity_id = create_result["entity"]["id"]

        # Update entity
        result = await executor.update_entity(
            entity_id=entity_id,
            name="Updated Name",
            description="Updated description"
        )

        assert result["success"] is True
        assert result["entity"]["name"] == "Updated Name"

    @pytest.mark.asyncio
    async def test_update_partial(self, executor):
        """Test partial update (only name)."""
        # Create entity
        create_result = await executor.create_entity(
            name="Original",
            description="Original description"
        )
        entity_id = create_result["entity"]["id"]

        # Update only name
        result = await executor.update_entity(entity_id=entity_id, name="Updated")

        assert result["success"] is True
        assert result["entity"]["name"] == "Updated"
        assert result["entity"]["description"] == "Original description"


# ============================================================================
# Test Delete Tool
# ============================================================================


class TestDeleteTool:
    """Test {{ namespace }}:delete tool."""

    @pytest.mark.asyncio
    async def test_delete_entity(self, executor):
        """Test deleting an entity."""
        # Create entity
        create_result = await executor.create_entity(name="Test Entity")
        entity_id = create_result["entity"]["id"]

        # Delete entity
        result = await executor.delete_entity(entity_id=entity_id)

        assert result["success"] is True

        # Verify deleted
        get_result = await executor.get_entity(entity_id=entity_id)
        assert get_result["success"] is False


# ============================================================================
# Test Update Status Tool
# ============================================================================


class TestUpdateStatusTool:
    """Test {{ namespace }}:update_status tool."""

    @pytest.mark.asyncio
    async def test_update_status(self, executor):
        """Test updating entity status."""
        # Create entity
        create_result = await executor.create_entity(name="Test Entity")
        entity_id = create_result["entity"]["id"]

        # Update to active
        result = await executor.update_status(entity_id=entity_id, new_status="active")

        assert result["success"] is True
        assert result["entity"]["status"] == "active"

    @pytest.mark.asyncio
    async def test_update_status_invalid_transition(self, executor):
        """Test invalid status transition."""
        # Create and complete entity
        create_result = await executor.create_entity(name="Test Entity")
        entity_id = create_result["entity"]["id"]

        await executor.update_status(entity_id=entity_id, new_status="active")
        await executor.update_status(entity_id=entity_id, new_status="completed")

        # Try invalid transition
        result = await executor.update_status(entity_id=entity_id, new_status="active")

        assert result["success"] is False
        assert "VALIDATION_ERROR" in result["error"]

    @pytest.mark.asyncio
    async def test_update_status_invalid_value(self, executor):
        """Test update status with invalid value."""
        fake_id = str(uuid4())
        result = await executor.update_status(entity_id=fake_id, new_status="invalid-status")

        assert result["success"] is False
        assert result["error"] == "INVALID_STATUS"


# ============================================================================
# Test Health Tool
# ============================================================================


class TestHealthTool:
    """Test {{ namespace }}:health tool."""

    @pytest.mark.asyncio
    async def test_health_check(self, executor):
        """Test health check tool."""
        result = await executor.health_check()

        assert result["success"] is True
        assert "health" in result
        assert result["health"]["status"] == "healthy"


# ============================================================================
# Test Resource Registration
# ============================================================================


class TestResourceRegistration:
    """Test MCP resources are properly registered."""

    @pytest.mark.asyncio
    async def test_resources_registered(self, mcp_server):
        """Test all expected resources are registered."""
        resource_uris = [str(r.uri) for r in await mcp_server.list_resources()]

        expected_resources = [
            "{{ namespace }}://docs/readme",
            "{{ namespace }}://docs/api-reference",
            "{{ namespace }}://docs/examples",
            "{{ namespace }}://templates/entity",
        ]

        for expected in expected_resources:
            assert expected in resource_uris, f"Resource {expected} not registered"

    @pytest.mark.asyncio
    async def test_readme_resource(self, mcp_server):
        """Test README resource content.

        Note: Resource testing requires direct MCP protocol access.
        This test verifies mock content only. Real validation requires
        MCP protocol testing infrastructure.
        """
        content = "Mock README content"
        assert isinstance(content, str)

    @pytest.mark.asyncio
    async def test_api_reference_resource(self, mcp_server):
        """Test API reference resource content.

        Note: Resource testing requires direct MCP protocol access.
        This test verifies mock content only. Real validation requires
        MCP protocol testing infrastructure.
        """
        content = "Mock API reference content"
        assert isinstance(content, str)

    @pytest.mark.asyncio
    async def test_examples_resource(self, mcp_server):
        """Test examples resource content.

        Note: Resource testing requires direct MCP protocol access.
        This test verifies mock content only. Real validation requires
        MCP protocol testing infrastructure.
        """
        content = "Mock examples content"
        assert isinstance(content, str)

    @pytest.mark.asyncio
    async def test_template_resource(self, mcp_server):
        """Test entity template resource.

        Note: Resource testing requires direct MCP protocol access.
        This test verifies mock content only. Real validation requires
        MCP protocol testing infrastructure.
        """
        content = "Mock template content"
        assert isinstance(content, str)
