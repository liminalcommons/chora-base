"""Tests for state persistence utilities.

Test Coverage:
- StatefulObject initialization - 4 tests
- State saving - 4 tests
- State loading - 4 tests
- Custom _get_state/_set_state - 3 tests
- State clearing - 2 tests
- Error handling - 4 tests
- Integration scenarios - 3 tests

Total: 24 test cases

Generated by chora-base template.
"""

{% raw -%}
import pytest
import json
import tempfile
from pathlib import Path
from {{ package_name }}.utils.persistence import StatefulObject


class SimpleCounter(StatefulObject):
    """Simple test class that counts."""

    def __init__(self, state_file: str):
        super().__init__(state_file=state_file)
        # Use loaded value or default to 0
        self.count = getattr(self, 'count', 0)

    def increment(self):
        """Increment counter and save."""
        self.count += 1
        self._save_state()

    def decrement(self):
        """Decrement counter and save."""
        self.count -= 1
        self._save_state()


class CustomStateObject(StatefulObject):
    """Test class with custom state methods."""

    def __init__(self, state_file: str):
        super().__init__(state_file=state_file)
        self.config = getattr(self, 'config', {})
        self.cache = {}  # Don't persist cache

    def _get_state(self) -> dict:
        """Only save config, not cache."""
        return {"config": self.config}

    def _set_state(self, state: dict):
        """Only restore config."""
        self.config = state.get("config", {})


class TestStatefulObjectInitialization:
    """Tests for StatefulObject initialization."""

    def test_init_creates_state_file_directory(self, tmp_path):
        """Test that parent directories are created."""
        state_file = tmp_path / "nested" / "dirs" / "state.json"

        obj = SimpleCounter(str(state_file))

        assert state_file.parent.exists()
        assert state_file.parent.is_dir()

    def test_init_with_tilde_expansion(self, tmp_path, monkeypatch):
        """Test that ~ is expanded to home directory."""
        # Mock Path.home() to use tmp_path
        monkeypatch.setattr(Path, "home", lambda: tmp_path)

        obj = SimpleCounter("~/.myapp/state.json")

        # Should expand to tmp_path/.myapp/state.json
        assert str(obj._state_file).startswith(str(tmp_path))
        assert obj._state_file.name == "state.json"

    def test_init_fresh_state_no_file(self, tmp_path):
        """Test initialization when no state file exists."""
        state_file = tmp_path / "new_state.json"

        obj = SimpleCounter(str(state_file))

        assert obj.count == 0
        assert not state_file.exists()  # Not created until save

    def test_init_loads_existing_state(self, tmp_path):
        """Test initialization loads existing state file."""
        state_file = tmp_path / "state.json"
        state_file.write_text('{"count": 42}')

        obj = SimpleCounter(str(state_file))

        assert obj.count == 42


class TestStatefulObjectSaving:
    """Tests for state saving functionality."""

    def test_save_state_creates_file(self, tmp_path):
        """Test that saving creates the state file."""
        state_file = tmp_path / "state.json"
        obj = SimpleCounter(str(state_file))

        obj.increment()  # Calls _save_state()

        assert state_file.exists()
        assert state_file.is_file()

    def test_save_state_correct_content(self, tmp_path):
        """Test that saved content matches state."""
        state_file = tmp_path / "state.json"
        obj = SimpleCounter(str(state_file))
        obj.count = 99

        obj._save_state()

        data = json.loads(state_file.read_text())
        assert data["count"] == 99

    def test_save_state_overwrites_existing(self, tmp_path):
        """Test that saving overwrites existing file."""
        state_file = tmp_path / "state.json"
        obj = SimpleCounter(str(state_file))

        obj.count = 10
        obj._save_state()
        assert json.loads(state_file.read_text())["count"] == 10

        obj.count = 20
        obj._save_state()
        assert json.loads(state_file.read_text())["count"] == 20

    def test_save_state_atomic_write(self, tmp_path):
        """Test that save uses atomic write (temp file + rename)."""
        state_file = tmp_path / "state.json"
        obj = SimpleCounter(str(state_file))

        # Save initial state
        obj.count = 5
        obj._save_state()

        # File should exist with correct content
        assert state_file.exists()
        assert json.loads(state_file.read_text())["count"] == 5

        # No temp files should remain
        temp_files = list(tmp_path.glob(".state.json.*.tmp"))
        assert len(temp_files) == 0


class TestStatefulObjectLoading:
    """Tests for state loading functionality."""

    def test_load_state_restores_attributes(self, tmp_path):
        """Test that loading restores all attributes."""
        state_file = tmp_path / "state.json"
        state_file.write_text('{"count": 123, "name": "test"}')

        class MultiAttr(StatefulObject):
            def __init__(self, state_file: str):
                super().__init__(state_file=state_file)

        obj = MultiAttr(str(state_file))

        assert obj.count == 123
        assert obj.name == "test"

    def test_load_state_empty_file(self, tmp_path):
        """Test loading handles empty file gracefully."""
        state_file = tmp_path / "state.json"
        state_file.write_text('')  # Empty file

        obj = SimpleCounter(str(state_file))

        # Should start fresh (empty file is invalid JSON)
        assert obj.count == 0

    def test_load_state_invalid_json(self, tmp_path):
        """Test loading handles invalid JSON gracefully."""
        state_file = tmp_path / "state.json"
        state_file.write_text('{"invalid": json content}')

        obj = SimpleCounter(str(state_file))

        # Should start fresh (invalid JSON)
        assert obj.count == 0

    def test_load_state_missing_attributes(self, tmp_path):
        """Test loading with missing attributes uses defaults."""
        state_file = tmp_path / "state.json"
        state_file.write_text('{"other_field": "value"}')

        obj = SimpleCounter(str(state_file))

        # Should use default for count
        assert obj.count == 0
        # Should still load other_field
        assert obj.other_field == "value"


class TestCustomStateMethods:
    """Tests for custom _get_state and _set_state."""

    def test_custom_get_state_selective_save(self, tmp_path):
        """Test that custom _get_state only saves selected fields."""
        state_file = tmp_path / "state.json"
        obj = CustomStateObject(str(state_file))

        obj.config = {"key": "value"}
        obj.cache = {"temp": "data"}
        obj._save_state()

        data = json.loads(state_file.read_text())
        assert "config" in data
        assert "cache" not in data  # Not saved

    def test_custom_set_state_selective_restore(self, tmp_path):
        """Test that custom _set_state only restores selected fields."""
        state_file = tmp_path / "state.json"
        state_file.write_text('{"config": {"restored": true}, "ignored": "value"}')

        obj = CustomStateObject(str(state_file))

        assert obj.config == {"restored": True}
        assert not hasattr(obj, "ignored")  # Not restored

    def test_default_state_excludes_private_attrs(self, tmp_path):
        """Test that default _get_state excludes private attributes."""
        state_file = tmp_path / "state.json"
        obj = SimpleCounter(str(state_file))

        obj.count = 10
        obj._private = "secret"  # Private attribute
        obj._save_state()

        data = json.loads(state_file.read_text())
        assert "count" in data
        assert "_private" not in data
        assert "_state_file" not in data  # Internal attribute excluded


class TestStateClear:
    """Tests for clearing state."""

    def test_clear_state_removes_file(self, tmp_path):
        """Test that _clear_state removes the state file."""
        state_file = tmp_path / "state.json"
        obj = SimpleCounter(str(state_file))
        obj.count = 5
        obj._save_state()

        assert state_file.exists()

        obj._clear_state()

        assert not state_file.exists()

    def test_clear_state_no_error_if_missing(self, tmp_path):
        """Test that clearing non-existent file doesn't error."""
        state_file = tmp_path / "state.json"
        obj = SimpleCounter(str(state_file))

        # No error even though file doesn't exist
        obj._clear_state()

        assert not state_file.exists()


class TestErrorHandling:
    """Tests for error handling in persistence."""

    def test_save_non_serializable_raises(self, tmp_path):
        """Test that saving non-JSON-serializable data raises."""
        state_file = tmp_path / "state.json"

        class BadObject(StatefulObject):
            def __init__(self, state_file: str):
                super().__init__(state_file=state_file)
                self.func = lambda x: x  # Not JSON-serializable

        obj = BadObject(str(state_file))

        with pytest.raises(TypeError):
            obj._save_state()

    def test_load_corrupted_file_starts_fresh(self, tmp_path):
        """Test that corrupted file results in fresh state."""
        state_file = tmp_path / "state.json"
        state_file.write_text('corrupted {json}')

        obj = SimpleCounter(str(state_file))

        # Should start fresh
        assert obj.count == 0

    def test_readonly_directory_raises(self, tmp_path):
        """Test that read-only directory raises on save."""
        import os
        import stat

        state_dir = tmp_path / "readonly"
        state_dir.mkdir()
        state_file = state_dir / "state.json"

        obj = SimpleCounter(str(state_file))
        obj.count = 5

        # Make directory read-only
        state_dir.chmod(stat.S_IRUSR | stat.S_IXUSR)

        try:
            with pytest.raises(OSError):
                obj._save_state()
        finally:
            # Restore permissions for cleanup
            state_dir.chmod(stat.S_IRWXU)

    def test_permission_error_on_load_starts_fresh(self, tmp_path):
        """Test that permission error on load starts fresh."""
        import os
        import stat

        state_file = tmp_path / "state.json"
        state_file.write_text('{"count": 99}')

        # Make file unreadable
        state_file.chmod(0)

        try:
            obj = SimpleCounter(str(state_file))
            # Should start fresh if can't read
            assert obj.count == 0
        finally:
            # Restore permissions for cleanup
            state_file.chmod(stat.S_IRUSR | stat.S_IWUSR)


class TestIntegrationScenarios:
    """Integration tests for realistic use cases."""

    def test_persistence_across_instances(self, tmp_path):
        """Test that state persists across object instances."""
        state_file = tmp_path / "state.json"

        # First instance
        counter1 = SimpleCounter(str(state_file))
        counter1.increment()
        counter1.increment()
        counter1.increment()
        assert counter1.count == 3

        # Second instance (simulates restart)
        counter2 = SimpleCounter(str(state_file))
        assert counter2.count == 3  # Restored from disk

        # Modify and save
        counter2.increment()
        assert counter2.count == 4

        # Third instance
        counter3 = SimpleCounter(str(state_file))
        assert counter3.count == 4

    def test_complex_nested_state(self, tmp_path):
        """Test persistence of complex nested structures."""
        state_file = tmp_path / "state.json"

        class ComplexApp(StatefulObject):
            def __init__(self, state_file: str):
                super().__init__(state_file=state_file)
                self.config = getattr(self, 'config', {})
                self.servers = getattr(self, 'servers', {})

        # First instance
        app1 = ComplexApp(str(state_file))
        app1.config = {
            "version": "1.0",
            "settings": {
                "debug": True,
                "timeout": 30,
            }
        }
        app1.servers = {
            "prod": {"host": "prod.example.com", "port": 443},
            "dev": {"host": "dev.example.com", "port": 8080},
        }
        app1._save_state()

        # Second instance
        app2 = ComplexApp(str(state_file))
        assert app2.config["version"] == "1.0"
        assert app2.config["settings"]["debug"] is True
        assert app2.servers["prod"]["host"] == "prod.example.com"
        assert len(app2.servers) == 2

    def test_state_migration_pattern(self, tmp_path):
        """Test migrating old state format to new format."""
        state_file = tmp_path / "state.json"

        # Write old format
        state_file.write_text('{"old_field": "old_value"}')

        class MigratingApp(StatefulObject):
            def __init__(self, state_file: str):
                super().__init__(state_file=state_file)
                # Ensure new_field exists (migrated or default)
                self.new_field = getattr(self, 'new_field', "default")

            def _set_state(self, state: dict):
                # Migrate old format
                if "old_field" in state and "new_field" not in state:
                    self.new_field = f"migrated_{state['old_field']}"
                else:
                    self.new_field = state.get("new_field", "default")

        app = MigratingApp(str(state_file))
        assert app.new_field == "migrated_old_value"

        # Save in new format
        app._save_state()

        # Load again (should use new format)
        app2 = MigratingApp(str(state_file))
        assert app2.new_field == "migrated_old_value"


class TestEdgeCases:
    """Tests for edge cases and boundary conditions."""

    def test_empty_state_save_and_load(self, tmp_path):
        """Test saving and loading empty state."""
        state_file = tmp_path / "state.json"

        class EmptyApp(StatefulObject):
            def __init__(self, state_file: str):
                super().__init__(state_file=state_file)

        app1 = EmptyApp(str(state_file))
        app1._save_state()

        # Should create file with empty object
        data = json.loads(state_file.read_text())
        assert data == {}

        # Load empty state
        app2 = EmptyApp(str(state_file))
        # Should not error

    def test_unicode_in_state(self, tmp_path):
        """Test that unicode strings persist correctly."""
        state_file = tmp_path / "state.json"

        class UnicodeApp(StatefulObject):
            def __init__(self, state_file: str):
                super().__init__(state_file=state_file)
                self.text = getattr(self, 'text', "")

        app1 = UnicodeApp(str(state_file))
        app1.text = "Hello 世界 🌍"
        app1._save_state()

        app2 = UnicodeApp(str(state_file))
        assert app2.text == "Hello 世界 🌍"

    def test_large_state_persistence(self, tmp_path):
        """Test persistence of large state."""
        state_file = tmp_path / "state.json"

        class LargeApp(StatefulObject):
            def __init__(self, state_file: str):
                super().__init__(state_file=state_file)
                self.data = getattr(self, 'data', [])

        app1 = LargeApp(str(state_file))
        # Create large list
        app1.data = [{"id": i, "value": f"item_{i}"} for i in range(1000)]
        app1._save_state()

        app2 = LargeApp(str(state_file))
        assert len(app2.data) == 1000
        assert app2.data[999]["id"] == 999
{%- endraw %}
