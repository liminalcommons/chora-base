"""Response builders for standardized API/tool responses.

This module provides utilities to build consistent response formats for
success, error, and partial success cases across all endpoints/tools.

Use cases:
- REST APIs: Consistent endpoint responses
- CLI tools: Structured command outputs
- RPC methods: Standardized return values
- MCP servers: Tool response formatting
- Microservices: Service-to-service communication

Generated by chora-base template.
"""

from typing import Any
import time
import logging

logger = logging.getLogger(__name__)


class Response:
    """Standardized response format builder.

    Provides class methods to build consistent response dictionaries for:
    - Success cases (.success)
    - Error cases (.error)
    - Partial success/batch operations (.partial)

    All responses include:
    - status: 'success', 'error', or 'partial'
    - timestamp: Unix timestamp of response creation
    - Automatic logging at appropriate level

    Examples:
        Success response:

            >>> Response.success(
            ...     action="created",
            ...     data={"id": 123, "name": "test"},
            ...     count=1,
            ... )
            {
                "status": "success",
                "action": "created",
                "data": {"id": 123, "name": "test"},
                "metadata": {"count": 1},
                "timestamp": 1698765432.123,
            }

        Error response:

            >>> Response.error(
            ...     error_code="not_found",
            ...     message="Server 'test' not found",
            ...     available=["prod", "dev"],
            ... )
            {
                "status": "error",
                "error_code": "not_found",
                "message": "Server 'test' not found",
                "recoverable": True,
                "details": {"available": ["prod", "dev"]},
                "timestamp": 1698765432.123,
            }

        Partial success (batch operations):

            >>> Response.partial(
            ...     action="deleted",
            ...     succeeded=["item1", "item2"],
            ...     failed=[{"id": "item3", "reason": "not found"}],
            ... )
            {
                "status": "partial",
                "action": "deleted",
                "succeeded": ["item1", "item2"],
                "failed": [{"id": "item3", "reason": "not found"}],
                "metadata": {
                    "succeeded_count": 2,
                    "failed_count": 1,
                },
                "timestamp": 1698765432.123,
            }
    """

    @classmethod
    def success(
        cls,
        action: str,
        data: Any = None,
        **metadata: Any,
    ) -> dict[str, Any]:
        """Create success response with optional data and metadata.

        Args:
            action: What action was performed (e.g., 'created', 'updated', 'deleted').
                Use past tense verbs for clarity.
            data: Result data (any type: dict, list, str, etc.).
                Can be None if action doesn't produce data.
            **metadata: Additional metadata as keyword arguments.
                Common examples: count, total, page, duration_ms.

        Returns:
            Standardized response dict with:
            - status: 'success'
            - action: The action performed
            - data: The provided data (or None)
            - metadata: Dict of all keyword arguments
            - timestamp: Unix timestamp (float)

        Examples:
            Simple success:

                >>> Response.success(action="deleted", data={"id": 123})
                {"status": "success", "action": "deleted", "data": {"id": 123}, ...}

            With metadata:

                >>> Response.success(
                ...     action="listed",
                ...     data=[{"id": 1}, {"id": 2}],
                ...     count=2,
                ...     total=100,
                ...     page=1,
                ... )
                {
                    "status": "success",
                    "action": "listed",
                    "data": [...],
                    "metadata": {"count": 2, "total": 100, "page": 1},
                    ...
                }

            No data:

                >>> Response.success(action="cleared")
                {"status": "success", "action": "cleared", "data": None, ...}
        """
        response = {
            "status": "success",
            "action": action,
            "data": data,
            "metadata": metadata,
            "timestamp": time.time(),
        }

        # Log at INFO level
        logger.info(f"Success: {action}", extra={"response": response})

        return response

    @classmethod
    def error(
        cls,
        error_code: str,
        message: str,
        recoverable: bool = True,
        **details: Any,
    ) -> dict[str, Any]:
        """Create error response with code, message, and optional details.

        Args:
            error_code: Machine-readable error code (e.g., 'not_found', 'invalid_parameter').
                Use snake_case for consistency.
            message: Human-readable error message.
                Should be clear, actionable, and specific.
            recoverable: Whether the error is recoverable (default: True).
                False for fatal errors (auth failure, resource exhausted).
            **details: Additional error context as keyword arguments.
                Examples: available (list of valid values), field (invalid field name).

        Returns:
            Standardized error dict with:
            - status: 'error'
            - error_code: The error code
            - message: The error message
            - recoverable: Whether error is recoverable
            - details: Dict of all keyword arguments
            - timestamp: Unix timestamp (float)

        Examples:
            Simple error:

                >>> Response.error(
                ...     error_code="not_found",
                ...     message="Server 'test' not found",
                ... )
                {
                    "status": "error",
                    "error_code": "not_found",
                    "message": "Server 'test' not found",
                    "recoverable": True,
                    ...
                }

            With details and suggestions:

                >>> Response.error(
                ...     error_code="not_found",
                ...     message="Server 'tset' not found. Did you mean 'test'?",
                ...     available=["test", "prod", "dev"],
                ... )
                {
                    "status": "error",
                    ...
                    "details": {"available": ["test", "prod", "dev"]},
                }

            Fatal error:

                >>> Response.error(
                ...     error_code="auth_failed",
                ...     message="Authentication failed",
                ...     recoverable=False,
                ... )
                {"status": "error", ..., "recoverable": False}
        """
        response = {
            "status": "error",
            "error_code": error_code,
            "message": message,
            "recoverable": recoverable,
            "details": details,
            "timestamp": time.time(),
        }

        # Log at ERROR level
        logger.error(
            f"Error: {error_code} - {message}",
            extra={"response": response}
        )

        return response

    @classmethod
    def partial(
        cls,
        action: str,
        succeeded: list[Any],
        failed: list[dict[str, Any]],
        **metadata: Any,
    ) -> dict[str, Any]:
        """Create partial success response for batch operations.

        Use when a batch operation completes with some successes and some failures.
        Automatically calculates succeeded_count and failed_count.

        Args:
            action: What action was attempted (e.g., 'created', 'deleted').
                Use past tense for consistency.
            succeeded: List of successfully processed items.
                Can be IDs, objects, or any representation.
            failed: List of failed items with failure reasons.
                Each item should be a dict with at minimum:
                - id/item: The failed item identifier
                - reason/error: Why it failed
            **metadata: Additional metadata as keyword arguments.

        Returns:
            Standardized partial response dict with:
            - status: 'partial'
            - action: The attempted action
            - succeeded: List of successful items
            - failed: List of failed items with reasons
            - metadata: Dict with succeeded_count, failed_count, and any kwargs
            - timestamp: Unix timestamp (float)

        Examples:
            Batch deletion with partial success:

                >>> Response.partial(
                ...     action="deleted",
                ...     succeeded=["item1", "item2"],
                ...     failed=[
                ...         {"id": "item3", "reason": "not found"},
                ...         {"id": "item4", "reason": "permission denied"},
                ...     ],
                ... )
                {
                    "status": "partial",
                    "action": "deleted",
                    "succeeded": ["item1", "item2"],
                    "failed": [{"id": "item3", ...}, {"id": "item4", ...}],
                    "metadata": {
                        "succeeded_count": 2,
                        "failed_count": 2,
                    },
                    ...
                }

            With additional metadata:

                >>> Response.partial(
                ...     action="imported",
                ...     succeeded=[{"id": 1}, {"id": 2}],
                ...     failed=[{"id": 3, "error": "invalid format"}],
                ...     total_attempted=3,
                ...     duration_ms=150,
                ... )
                {
                    "metadata": {
                        "succeeded_count": 2,
                        "failed_count": 1,
                        "total_attempted": 3,
                        "duration_ms": 150,
                    },
                    ...
                }
        """
        response = {
            "status": "partial",
            "action": action,
            "succeeded": succeeded,
            "failed": failed,
            "metadata": {
                **metadata,
                "succeeded_count": len(succeeded),
                "failed_count": len(failed),
            },
            "timestamp": time.time(),
        }

        # Log at WARNING level (partial success is concerning)
        total = len(succeeded) + len(failed)
        logger.warning(
            f"Partial: {action} - {len(succeeded)}/{total} succeeded",
            extra={"response": response}
        )

        return response


__all__ = ["Response"]
