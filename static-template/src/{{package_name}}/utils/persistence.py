"""State persistence utilities for stateful applications.

This module provides utilities to automatically persist object state to disk:
- StatefulObject: Mixin class for auto-persisted state
- Atomic file writes to prevent corruption
- JSON serialization with error handling
- Automatic directory creation

Use cases:
- CLI tools: Save session state, preferences
- Daemons: Persist configuration between restarts
- Services: Save draft/pending operations
- MCP servers: Persist draft configurations
- Applications: Cache computed results

Generated by chora-base template.
"""

from pathlib import Path
from typing import Any
import json
import tempfile
import shutil
import logging
from abc import ABC

logger = logging.getLogger(__name__)


class StatefulObject(ABC):
    """Mixin class for objects with auto-persisted state.

    Provides automatic state persistence to JSON files with:
    - Lazy loading on initialization
    - Explicit saving via _save_state()
    - Atomic writes to prevent corruption
    - Automatic directory creation
    - Customizable serialization via _get_state() and _set_state()

    Usage:
        Inherit from StatefulObject and call super().__init__() with state_file:

        class MyService(StatefulObject):
            def __init__(self):
                super().__init__(state_file="~/.myapp/state.json")
                self.config = self.config or {}  # Use loaded or default

            def update_config(self, config: dict):
                self.config = config
                self._save_state()  # Explicitly save changes

    State Management:
        - Override _get_state() to customize what gets saved
        - Override _set_state() to customize restoration
        - Default: saves all non-private attributes (not starting with _)

    Examples:
        Basic usage:

            >>> class Counter(StatefulObject):
            ...     def __init__(self, state_file: str):
            ...         super().__init__(state_file=state_file)
            ...         self.count = getattr(self, 'count', 0)
            ...
            ...     def increment(self):
            ...         self.count += 1
            ...         self._save_state()
            ...
            >>> counter = Counter("/tmp/counter.json")
            >>> counter.increment()
            >>> counter.count
            1
            >>> # Later, in new process:
            >>> counter2 = Counter("/tmp/counter.json")
            >>> counter2.count  # Restored from disk
            1

        Custom state selection:

            >>> class MyApp(StatefulObject):
            ...     def __init__(self):
            ...         super().__init__(state_file="~/.myapp/state.json")
            ...         self.config = getattr(self, 'config', {})
            ...         self.cache = {}  # Don't persist cache
            ...
            ...     def _get_state(self) -> dict:
            ...         # Only save config, not cache
            ...         return {"config": self.config}
            ...
            ...     def _set_state(self, state: dict):
            ...         self.config = state.get("config", {})

        With nested objects:

            >>> class Server(StatefulObject):
            ...     def __init__(self):
            ...         super().__init__(state_file="~/.servers/state.json")
            ...         self.servers = getattr(self, 'servers', {})
            ...
            ...     def add_server(self, name: str, config: dict):
            ...         self.servers[name] = config
            ...         self._save_state()
    """

    def __init__(self, state_file: Path | str, **kwargs):
        """Initialize stateful object with persistence.

        Args:
            state_file: Path to state persistence file.
                Supports tilde expansion (~/.myapp/state.json).
                Parent directories created automatically.
            **kwargs: Additional arguments passed to parent class.

        Side Effects:
            - Creates parent directories if they don't exist
            - Loads state from file if it exists
            - Sets self._state_file (private)

        Raises:
            OSError: If directory creation fails
            json.JSONDecodeError: If state file has invalid JSON
            PermissionError: If insufficient permissions for file/directory
        """
        super().__init__(**kwargs)

        # Expand ~ and convert to absolute path
        self._state_file = Path(state_file).expanduser().resolve()

        # Create parent directories if needed
        self._state_file.parent.mkdir(parents=True, exist_ok=True)

        # Load existing state if file exists
        self._load_state()

        logger.debug(
            f"Initialized StatefulObject with state_file: {self._state_file}"
        )

    def _save_state(self):
        """Save current state to disk atomically.

        Uses atomic write pattern:
        1. Write to temporary file in same directory
        2. Fsync to ensure data on disk
        3. Atomic rename to target file

        This prevents corruption if write is interrupted (crash, power loss).

        Side Effects:
            - Calls _get_state() to get current state
            - Writes JSON to state_file
            - Creates temporary file (cleaned up automatically)

        Raises:
            OSError: If write or rename fails
            TypeError: If state contains non-JSON-serializable objects

        Example:
            >>> class MyApp(StatefulObject):
            ...     def update(self, data: dict):
            ...         self.data = data
            ...         self._save_state()  # Persist immediately
        """
        # Get state to persist
        state = self._get_state()

        # Atomic write: write to temp file, then rename
        # This prevents corruption if process dies mid-write
        temp_fd, temp_path = tempfile.mkstemp(
            dir=self._state_file.parent,
            prefix=f".{self._state_file.name}.",
            suffix=".tmp",
        )

        try:
            # Write JSON to temp file
            with open(temp_fd, 'w') as f:
                json.dump(state, f, indent=2, sort_keys=True)
                f.flush()
                # Ensure data written to disk (not just OS buffer)
                import os
                os.fsync(f.fileno())

            # Atomic rename: replaces old file in single operation
            shutil.move(temp_path, self._state_file)

            logger.debug(f"Saved state to {self._state_file}")

        except Exception as e:
            # Clean up temp file on error
            try:
                Path(temp_path).unlink(missing_ok=True)
            except Exception:
                pass  # Best effort cleanup

            logger.error(f"Failed to save state to {self._state_file}: {e}")
            raise

    def _load_state(self):
        """Load state from disk if file exists.

        Side Effects:
            - Reads JSON from state_file if it exists
            - Calls _set_state() to restore attributes
            - Logs errors but does not raise (graceful degradation)

        Behavior:
            - If file doesn't exist: No-op (new state)
            - If file has invalid JSON: Logs error, starts fresh
            - If file is empty: Starts fresh

        Example:
            >>> # Automatically called in __init__
            >>> obj = StatefulObject(state_file="state.json")
            >>> # State loaded from disk if state.json exists
        """
        if not self._state_file.exists():
            logger.debug(f"No state file found at {self._state_file}, starting fresh")
            return

        try:
            with open(self._state_file) as f:
                state = json.load(f)

            # Restore state
            self._set_state(state)

            logger.debug(f"Loaded state from {self._state_file}")

        except json.JSONDecodeError as e:
            logger.error(
                f"Invalid JSON in state file {self._state_file}: {e}. "
                "Starting with fresh state."
            )
            # Don't raise - gracefully start fresh

        except Exception as e:
            logger.error(
                f"Failed to load state from {self._state_file}: {e}. "
                "Starting with fresh state."
            )
            # Don't raise - gracefully start fresh

    def _get_state(self) -> dict[str, Any]:
        """Get current state to persist.

        Override this method to customize what gets saved.

        Default behavior:
            Saves all non-private attributes (not starting with underscore).

        Returns:
            Dictionary of state to save. Must be JSON-serializable.

        Raises:
            TypeError: If state contains non-JSON-serializable objects

        Examples:
            Default (save all public attributes):

                >>> class MyApp(StatefulObject):
                ...     def __init__(self):
                ...         super().__init__(state_file="state.json")
                ...         self.config = {"key": "value"}
                ...         self.data = [1, 2, 3]
                ...         self._cache = {}  # Won't be saved (private)
                ...
                >>> app = MyApp()
                >>> app._get_state()
                {"config": {"key": "value"}, "data": [1, 2, 3]}

            Custom selection:

                >>> class MyApp(StatefulObject):
                ...     def _get_state(self) -> dict:
                ...         # Only save specific fields
                ...         return {
                ...             "config": self.config,
                ...             "version": self.version,
                ...         }

            With transformation:

                >>> class MyApp(StatefulObject):
                ...     def _get_state(self) -> dict:
                ...         # Transform before saving
                ...         return {
                ...             "servers": {
                ...                 k: v.to_dict()  # Convert objects to dicts
                ...                 for k, v in self.servers.items()
                ...             }
                ...         }
        """
        # Default: save all non-private attributes
        return {
            key: value
            for key, value in self.__dict__.items()
            if not key.startswith('_')
        }

    def _set_state(self, state: dict[str, Any]):
        """Restore state from loaded data.

        Override this method to customize state restoration.

        Default behavior:
            Restores all attributes from state dict.

        Args:
            state: Dictionary of state loaded from disk.

        Side Effects:
            Sets attributes on self based on state dict.

        Examples:
            Default (restore all attributes):

                >>> class MyApp(StatefulObject):
                ...     pass  # Uses default _set_state
                ...
                >>> app = MyApp(state_file="state.json")
                >>> # If state.json contains {"config": {...}, "data": [...]}
                >>> # Then app.config and app.data are set automatically

            Custom restoration:

                >>> class MyApp(StatefulObject):
                ...     def _set_state(self, state: dict):
                ...         # Validate before restoring
                ...         self.config = state.get("config", {})
                ...         if "version" in state:
                ...             self.version = state["version"]

            With transformation:

                >>> class MyApp(StatefulObject):
                ...     def _set_state(self, state: dict):
                ...         # Transform when restoring
                ...         self.servers = {
                ...             k: Server.from_dict(v)  # Convert dicts to objects
                ...             for k, v in state.get("servers", {}).items()
                ...         }

            With migration:

                >>> class MyApp(StatefulObject):
                ...     def _set_state(self, state: dict):
                ...         # Migrate old state format
                ...         if "old_field" in state:
                ...             self.new_field = migrate(state["old_field"])
                ...         else:
                ...             self.new_field = state.get("new_field")
        """
        # Default: restore all attributes
        for key, value in state.items():
            setattr(self, key, value)

    def _clear_state(self):
        """Clear persisted state file from disk.

        Useful for testing or when user requests data deletion.

        Side Effects:
            - Deletes state file if it exists
            - Does NOT clear in-memory state (use _reset_state for that)

        Raises:
            OSError: If file deletion fails due to permissions

        Example:
            >>> class MyApp(StatefulObject):
            ...     def reset(self):
            ...         self._clear_state()  # Delete file
            ...         self.__init__()       # Reinitialize fresh
        """
        if self._state_file.exists():
            self._state_file.unlink()
            logger.debug(f"Cleared state file: {self._state_file}")


__all__ = ["StatefulObject"]
