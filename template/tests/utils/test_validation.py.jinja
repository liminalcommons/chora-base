"""Tests for {{ package_name }}.utils.validation module.

Comprehensive test suite for input normalization and parameter validation.
Tests cover all InputFormat types, error conditions, and edge cases.

Generated by chora-base template.
"""

import pytest
import json
from {{ package_name }}.utils.validation import (
    InputFormat,
    normalize_input,
    parse_kv_args,
    _convert_param,
)


# =============================================================================
# Tests for _convert_param (internal helper)
# =============================================================================

class TestConvertParam:
    """Tests for _convert_param helper function."""

    def test_none_always_passes_through(self):
        """Test that None value passes through for all format types."""
        for format_type in InputFormat:
            result = _convert_param(None, format_type, "test_param")
            assert result is None

    # -------------------------------------------------------------------------
    # DICT_ONLY format tests
    # -------------------------------------------------------------------------

    def test_dict_only_with_dict(self):
        """Test DICT_ONLY accepts dict."""
        data = {"key": "value", "num": 42}
        result = _convert_param(data, InputFormat.DICT_ONLY, "data")
        assert result == {"key": "value", "num": 42}
        assert result is data  # Same object

    def test_dict_only_rejects_string(self):
        """Test DICT_ONLY rejects string."""
        with pytest.raises(TypeError, match="must be dict"):
            _convert_param("not a dict", InputFormat.DICT_ONLY, "data")

    def test_dict_only_rejects_list(self):
        """Test DICT_ONLY rejects list."""
        with pytest.raises(TypeError, match="must be dict"):
            _convert_param([1, 2, 3], InputFormat.DICT_ONLY, "data")

    # -------------------------------------------------------------------------
    # DICT_OR_JSON format tests
    # -------------------------------------------------------------------------

    def test_dict_or_json_with_dict(self):
        """Test DICT_OR_JSON accepts dict."""
        data = {"key": "value"}
        result = _convert_param(data, InputFormat.DICT_OR_JSON, "data")
        assert result == {"key": "value"}

    def test_dict_or_json_with_valid_json_string(self):
        """Test DICT_OR_JSON converts valid JSON string."""
        json_str = '{"key": "value", "num": 42}'
        result = _convert_param(json_str, InputFormat.DICT_OR_JSON, "data")
        assert result == {"key": "value", "num": 42}

    def test_dict_or_json_with_empty_json_object(self):
        """Test DICT_OR_JSON handles empty JSON object."""
        result = _convert_param("{}", InputFormat.DICT_OR_JSON, "data")
        assert result == {}

    def test_dict_or_json_with_nested_json(self):
        """Test DICT_OR_JSON handles nested JSON."""
        json_str = '{"outer": {"inner": "value"}}'
        result = _convert_param(json_str, InputFormat.DICT_OR_JSON, "data")
        assert result == {"outer": {"inner": "value"}}

    def test_dict_or_json_rejects_invalid_json(self):
        """Test DICT_OR_JSON rejects malformed JSON."""
        with pytest.raises(ValueError, match="invalid JSON"):
            _convert_param("{bad json}", InputFormat.DICT_OR_JSON, "data")

    def test_dict_or_json_rejects_json_array(self):
        """Test DICT_OR_JSON rejects JSON array (must be object)."""
        with pytest.raises(ValueError, match="must be object/dict"):
            _convert_param("[1, 2, 3]", InputFormat.DICT_OR_JSON, "data")

    def test_dict_or_json_rejects_json_primitive(self):
        """Test DICT_OR_JSON rejects JSON primitive."""
        with pytest.raises(ValueError, match="must be object/dict"):
            _convert_param('"just a string"', InputFormat.DICT_OR_JSON, "data")

    def test_dict_or_json_rejects_integer(self):
        """Test DICT_OR_JSON rejects integer."""
        with pytest.raises(TypeError, match="must be dict or JSON string"):
            _convert_param(42, InputFormat.DICT_OR_JSON, "data")

    # -------------------------------------------------------------------------
    # KV_PAIRS format tests
    # -------------------------------------------------------------------------

    def test_kv_pairs_with_list(self):
        """Test KV_PAIRS converts list of key=value strings."""
        args = ["key1=value1", "key2=value2"]
        result = _convert_param(args, InputFormat.KV_PAIRS, "args")
        assert result == {"key1": "value1", "key2": "value2"}

    def test_kv_pairs_with_tuple(self):
        """Test KV_PAIRS converts tuple of key=value strings."""
        args = ("host=localhost", "port=5432")
        result = _convert_param(args, InputFormat.KV_PAIRS, "args")
        assert result == {"host": "localhost", "port": "5432"}

    def test_kv_pairs_with_spaces_in_value(self):
        """Test KV_PAIRS handles values with spaces."""
        args = ["name=John Doe", "city=New York"]
        result = _convert_param(args, InputFormat.KV_PAIRS, "args")
        assert result == {"name": "John Doe", "city": "New York"}

    def test_kv_pairs_with_equals_in_value(self):
        """Test KV_PAIRS handles equals sign in value (split on first =)."""
        args = ["equation=x=y+z", "formula=a=b"]
        result = _convert_param(args, InputFormat.KV_PAIRS, "args")
        assert result == {"equation": "x=y+z", "formula": "a=b"}

    def test_kv_pairs_with_whitespace_stripping(self):
        """Test KV_PAIRS strips whitespace from keys and values."""
        args = ["  key1  =  value1  ", "key2=value2"]
        result = _convert_param(args, InputFormat.KV_PAIRS, "args")
        assert result == {"key1": "value1", "key2": "value2"}

    def test_kv_pairs_with_empty_list(self):
        """Test KV_PAIRS handles empty list."""
        result = _convert_param([], InputFormat.KV_PAIRS, "args")
        assert result == {}

    def test_kv_pairs_accepts_dict_passthrough(self):
        """Test KV_PAIRS accepts dict and passes through."""
        data = {"key": "value"}
        result = _convert_param(data, InputFormat.KV_PAIRS, "args")
        assert result == {"key": "value"}

    def test_kv_pairs_rejects_item_without_equals(self):
        """Test KV_PAIRS rejects item missing equals sign."""
        with pytest.raises(ValueError, match="not in 'key=value' format"):
            _convert_param(["key1=val1", "baditem"], InputFormat.KV_PAIRS, "args")

    def test_kv_pairs_rejects_non_string_item(self):
        """Test KV_PAIRS rejects non-string items in list."""
        with pytest.raises(ValueError, match="not in 'key=value' format"):
            _convert_param(["key1=val1", 42], InputFormat.KV_PAIRS, "args")

    def test_kv_pairs_rejects_string(self):
        """Test KV_PAIRS rejects plain string."""
        with pytest.raises(TypeError, match="must be list"):
            _convert_param("key=value", InputFormat.KV_PAIRS, "args")

    # -------------------------------------------------------------------------
    # DICT_OR_KV format tests
    # -------------------------------------------------------------------------

    def test_dict_or_kv_with_dict(self):
        """Test DICT_OR_KV accepts dict."""
        data = {"key": "value"}
        result = _convert_param(data, InputFormat.DICT_OR_KV, "data")
        assert result == {"key": "value"}

    def test_dict_or_kv_with_kv_list(self):
        """Test DICT_OR_KV converts key=value list."""
        args = ["k1=v1", "k2=v2"]
        result = _convert_param(args, InputFormat.DICT_OR_KV, "data")
        assert result == {"k1": "v1", "k2": "v2"}

    def test_dict_or_kv_rejects_string(self):
        """Test DICT_OR_KV rejects plain string."""
        with pytest.raises(TypeError, match="must be dict or list"):
            _convert_param("invalid", InputFormat.DICT_OR_KV, "data")


# =============================================================================
# Tests for normalize_input decorator
# =============================================================================

class TestNormalizeInputDecorator:
    """Tests for normalize_input decorator with sync and async functions."""

    # -------------------------------------------------------------------------
    # Sync function tests
    # -------------------------------------------------------------------------

    def test_sync_function_with_dict_or_json(self):
        """Test normalize_input with sync function and DICT_OR_JSON."""
        @normalize_input(params=InputFormat.DICT_OR_JSON)
        def my_func(params: dict | None = None):
            return params

        # Test with dict
        result = my_func(params={"key": "value"})
        assert result == {"key": "value"}

        # Test with JSON string
        result = my_func(params='{"key": "value"}')
        assert result == {"key": "value"}

        # Test with None
        result = my_func(params=None)
        assert result is None

    def test_sync_function_with_kv_pairs(self):
        """Test normalize_input with sync function and KV_PAIRS."""
        @normalize_input(opts=InputFormat.KV_PAIRS)
        def configure(opts: dict):
            return opts

        result = configure(opts=["k1=v1", "k2=v2"])
        assert result == {"k1": "v1", "k2": "v2"}

    def test_sync_function_with_multiple_params(self):
        """Test normalize_input with multiple parameters."""
        @normalize_input(
            params=InputFormat.DICT_OR_JSON,
            env_vars=InputFormat.DICT_OR_JSON,
        )
        def my_func(params: dict | None, env_vars: dict | None):
            return {"params": params, "env_vars": env_vars}

        result = my_func(
            params='{"key": "value"}',
            env_vars={"PATH": "/usr/bin"},
        )
        assert result == {
            "params": {"key": "value"},
            "env_vars": {"PATH": "/usr/bin"},
        }

    def test_sync_function_leaves_other_params_untouched(self):
        """Test that unspecified parameters pass through unchanged."""
        @normalize_input(data=InputFormat.DICT_OR_JSON)
        def my_func(data: dict, name: str, count: int):
            return {"data": data, "name": name, "count": count}

        result = my_func(data='{"key": "val"}', name="test", count=42)
        assert result == {
            "data": {"key": "val"},
            "name": "test",
            "count": 42,
        }

    # -------------------------------------------------------------------------
    # Async function tests
    # -------------------------------------------------------------------------

    @pytest.mark.asyncio
    async def test_async_function_with_dict_or_json(self):
        """Test normalize_input with async function and DICT_OR_JSON."""
        @normalize_input(params=InputFormat.DICT_OR_JSON)
        async def my_async_func(params: dict | None = None):
            return params

        # Test with dict
        result = await my_async_func(params={"key": "value"})
        assert result == {"key": "value"}

        # Test with JSON string
        result = await my_async_func(params='{"key": "value"}')
        assert result == {"key": "value"}

    @pytest.mark.asyncio
    async def test_async_function_with_multiple_params(self):
        """Test normalize_input with async function and multiple params."""
        @normalize_input(
            params=InputFormat.DICT_OR_JSON,
            opts=InputFormat.KV_PAIRS,
        )
        async def process(params: dict, opts: dict | None = None):
            return {"params": params, "opts": opts}

        result = await process(
            params='{"data": 123}',
            opts=["verbose=true", "mode=fast"],
        )
        assert result == {
            "params": {"data": 123},
            "opts": {"verbose": "true", "mode": "fast"},
        }

    # -------------------------------------------------------------------------
    # Error propagation tests
    # -------------------------------------------------------------------------

    def test_decorator_propagates_type_error(self):
        """Test that TypeErrors from conversion are propagated."""
        @normalize_input(data=InputFormat.DICT_ONLY)
        def my_func(data: dict):
            return data

        with pytest.raises(TypeError, match="must be dict"):
            my_func(data="not a dict")

    def test_decorator_propagates_value_error(self):
        """Test that ValueErrors from conversion are propagated."""
        @normalize_input(data=InputFormat.DICT_OR_JSON)
        def my_func(data: dict):
            return data

        with pytest.raises(ValueError, match="invalid JSON"):
            my_func(data="{bad json}")

    # -------------------------------------------------------------------------
    # Edge cases
    # -------------------------------------------------------------------------

    def test_decorator_with_no_params_specified(self):
        """Test decorator works when no params need normalization."""
        @normalize_input()
        def my_func(name: str):
            return name

        assert my_func(name="test") == "test"

    def test_decorator_with_positional_args(self):
        """Test decorator works with positional arguments."""
        @normalize_input(opts=InputFormat.KV_PAIRS)
        def my_func(name: str, opts: dict):
            return {"name": name, "opts": opts}

        # Positional arg + keyword arg
        result = my_func("test", opts=["k=v"])
        assert result == {"name": "test", "opts": {"k": "v"}}


# =============================================================================
# Tests for parse_kv_args convenience function
# =============================================================================

class TestParseKvArgs:
    """Tests for parse_kv_args convenience function."""

    def test_parse_kv_args_with_list(self):
        """Test parse_kv_args with list of strings."""
        result = parse_kv_args(["host=localhost", "port=5432", "db=mydb"])
        assert result == {"host": "localhost", "port": "5432", "db": "mydb"}

    def test_parse_kv_args_with_tuple(self):
        """Test parse_kv_args with tuple (CLI Click multiple option)."""
        result = parse_kv_args(("key1=val1", "key2=val2"))
        assert result == {"key1": "val1", "key2": "val2"}

    def test_parse_kv_args_with_empty_list(self):
        """Test parse_kv_args with empty list."""
        result = parse_kv_args([])
        assert result == {}

    def test_parse_kv_args_error_on_invalid_format(self):
        """Test parse_kv_args raises error for invalid format."""
        with pytest.raises(ValueError, match="not in 'key=value' format"):
            parse_kv_args(["valid=yes", "invalid_no_equals"])


# =============================================================================
# Integration tests (realistic use cases)
# =============================================================================

class TestIntegrationScenarios:
    """Integration tests with realistic scenarios."""

    def test_mcp_tool_scenario(self):
        """Test MCP tool with params and env_vars normalization."""
        @normalize_input(
            params=InputFormat.DICT_OR_JSON,
            env_vars=InputFormat.DICT_OR_JSON,
        )
        def add_server(
            server_id: str,
            params: dict | None = None,
            env_vars: dict | None = None,
        ):
            return {
                "server_id": server_id,
                "params": params or {},
                "env_vars": env_vars or {},
            }

        # Scenario 1: Both as dicts
        result = add_server(
            server_id="github",
            params={"token": "secret"},
            env_vars={"PATH": "/usr/bin"},
        )
        assert result["params"] == {"token": "secret"}

        # Scenario 2: params as JSON string (from Claude Desktop)
        result = add_server(
            server_id="github",
            params='{"token": "secret"}',
            env_vars={"PATH": "/usr/bin"},
        )
        assert result["params"] == {"token": "secret"}

    def test_cli_tool_scenario(self):
        """Test CLI tool with key=value argument parsing."""
        @normalize_input(config=InputFormat.KV_PAIRS)
        def cli_configure(config: dict):
            return {"config": config}

        # Simulate Click's multiple option
        result = cli_configure(
            config=("host=localhost", "port=8080", "debug=true")
        )
        assert result["config"] == {
            "host": "localhost",
            "port": "8080",
            "debug": "true",
        }

    def test_rest_api_scenario(self):
        """Test REST API endpoint with JSON body normalization."""
        @normalize_input(body=InputFormat.DICT_OR_JSON)
        def api_endpoint(body: dict):
            return {"received": body}

        # Scenario 1: Already parsed by framework
        result = api_endpoint(body={"name": "test", "value": 42})
        assert result["received"] == {"name": "test", "value": 42}

        # Scenario 2: Raw JSON string (some frameworks)
        result = api_endpoint(body='{"name": "test", "value": 42}')
        assert result["received"] == {"name": "test", "value": 42}
