"""Input normalization and parameter validation utilities.

This module provides decorators and helpers to normalize inputs from multiple
sources (JSON strings, dicts, key=value pairs) into consistent Python types.

Use cases:
- REST APIs: Accept JSON string or parsed dict
- CLI tools: Parse --param key=value arguments
- RPC servers: Handle serialized parameters
- MCP servers: Normalize protocol variations
- Config parsers: Support YAML/JSON/TOML inputs

Generated by chora-base template.
"""

from enum import Enum
from functools import wraps
from typing import Any, Callable
import json
import inspect


class InputFormat(Enum):
    """Supported input formats for parameter normalization.

    Attributes:
        DICT_ONLY: Only accept dict type (no conversion)
        DICT_OR_JSON: Accept dict or JSON string, convert to dict
        KV_PAIRS: Accept list of "key=value" strings, convert to dict
        DICT_OR_KV: Accept dict or list of "key=value" strings, convert to dict
    """
    DICT_ONLY = "dict_only"
    DICT_OR_JSON = "dict_or_json"
    KV_PAIRS = "kv_pairs"
    DICT_OR_KV = "dict_or_kv"


def normalize_input(**param_specs: InputFormat) -> Callable:
    """Decorator to auto-convert parameter formats.

    Normalizes function parameters from various input formats (JSON strings,
    key=value pairs, etc.) into consistent Python types (dicts).

    Args:
        **param_specs: Mapping of parameter names to InputFormat values.
            Each specified parameter will be converted according to its format.

    Returns:
        Decorator function that wraps the original function.

    Raises:
        TypeError: If parameter is wrong type after conversion attempt.
        ValueError: If parameter cannot be converted (e.g., invalid JSON).

    Examples:
        Basic usage with async function:

            >>> @normalize_input(
            ...     params=InputFormat.DICT_OR_JSON,
            ...     env_vars=InputFormat.DICT_OR_JSON,
            ... )
            ... async def my_tool(params: dict | None = None, env_vars: dict | None = None):
            ...     # params and env_vars are guaranteed to be dict or None
            ...     print(params)

        With CLI key=value pairs:

            >>> @normalize_input(config=InputFormat.KV_PAIRS)
            ... def configure(config: dict):
            ...     # config converted from ["key1=val1", "key2=val2"] to dict
            ...     print(config)

        Mixed formats:

            >>> @normalize_input(
            ...     data=InputFormat.DICT_OR_JSON,
            ...     options=InputFormat.DICT_OR_KV,
            ... )
            ... def process(data: dict, options: dict | None = None):
            ...     # Both parameters normalized to dict
            ...     pass
    """
    def decorator(func: Callable) -> Callable:
        """Inner decorator that applies normalization."""

        # Detect if function is async or sync
        is_async = inspect.iscoroutinefunction(func)

        if is_async:
            @wraps(func)
            async def async_wrapper(*args, **kwargs):
                """Async wrapper for parameter normalization."""
                # Convert each specified parameter
                for param_name, format_type in param_specs.items():
                    if param_name in kwargs:
                        kwargs[param_name] = _convert_param(
                            kwargs[param_name],
                            format_type,
                            param_name,
                        )
                return await func(*args, **kwargs)
            return async_wrapper
        else:
            @wraps(func)
            def sync_wrapper(*args, **kwargs):
                """Sync wrapper for parameter normalization."""
                # Convert each specified parameter
                for param_name, format_type in param_specs.items():
                    if param_name in kwargs:
                        kwargs[param_name] = _convert_param(
                            kwargs[param_name],
                            format_type,
                            param_name,
                        )
                return func(*args, **kwargs)
            return sync_wrapper

    return decorator


def _convert_param(value: Any, format_type: InputFormat, param_name: str) -> Any:
    """Convert parameter based on format type.

    Internal helper for normalize_input decorator. Handles conversion logic
    for each InputFormat type.

    Args:
        value: Parameter value to convert.
        format_type: Desired format type from InputFormat enum.
        param_name: Parameter name (for error messages).

    Returns:
        Converted value in the target format.

    Raises:
        TypeError: If value is wrong type for the specified format.
        ValueError: If value cannot be converted (e.g., malformed JSON).

    Examples:
        >>> _convert_param({"key": "value"}, InputFormat.DICT_ONLY, "data")
        {'key': 'value'}

        >>> _convert_param('{"key": "value"}', InputFormat.DICT_OR_JSON, "data")
        {'key': 'value'}

        >>> _convert_param(["k1=v1", "k2=v2"], InputFormat.KV_PAIRS, "opts")
        {'k1': 'v1', 'k2': 'v2'}
    """
    # None always passes through unchanged
    if value is None:
        return None

    if format_type == InputFormat.DICT_ONLY:
        # Strict: only accept dict
        if not isinstance(value, dict):
            raise TypeError(
                f"Parameter '{param_name}' must be dict, "
                f"got {type(value).__name__}"
            )
        return value

    elif format_type == InputFormat.DICT_OR_JSON:
        # Accept dict or JSON string
        if isinstance(value, str):
            try:
                parsed = json.loads(value)
                if not isinstance(parsed, dict):
                    raise ValueError(
                        f"Parameter '{param_name}' JSON must be object/dict, "
                        f"got {type(parsed).__name__}"
                    )
                return parsed
            except json.JSONDecodeError as e:
                raise ValueError(
                    f"Parameter '{param_name}' is invalid JSON: {e}\n"
                    f"Expected: dict or JSON string"
                ) from e
        elif isinstance(value, dict):
            return value
        else:
            raise TypeError(
                f"Parameter '{param_name}' must be dict or JSON string, "
                f"got {type(value).__name__}"
            )

    elif format_type == InputFormat.KV_PAIRS:
        # Accept list/tuple of "key=value" strings or dict
        if isinstance(value, (list, tuple)):
            result = {}
            for item in value:
                if isinstance(item, str) and "=" in item:
                    key, val = item.split("=", 1)
                    result[key.strip()] = val.strip()
                else:
                    raise ValueError(
                        f"Parameter '{param_name}' item '{item}' is not in "
                        f"'key=value' format"
                    )
            return result
        elif isinstance(value, dict):
            # Already a dict, pass through
            return value
        else:
            raise TypeError(
                f"Parameter '{param_name}' must be list of 'key=value' strings "
                f"or dict, got {type(value).__name__}"
            )

    elif format_type == InputFormat.DICT_OR_KV:
        # Accept dict or list of "key=value" strings
        if isinstance(value, dict):
            return value
        elif isinstance(value, (list, tuple)):
            # Delegate to KV_PAIRS conversion logic
            return _convert_param(value, InputFormat.KV_PAIRS, param_name)
        else:
            raise TypeError(
                f"Parameter '{param_name}' must be dict or list of 'key=value' "
                f"strings, got {type(value).__name__}"
            )

    # Unknown format type (shouldn't happen with enum)
    return value


# Convenience function for CLI argument parsing
def parse_kv_args(args: list[str] | tuple[str, ...]) -> dict[str, str]:
    """Parse CLI key=value arguments into dict.

    Convenience function for CLI tools that receive multiple --arg key=value
    parameters. Equivalent to using _convert_param with InputFormat.KV_PAIRS.

    Args:
        args: List or tuple of "key=value" strings.

    Returns:
        Dictionary with parsed key-value pairs.

    Raises:
        ValueError: If any argument is not in "key=value" format.

    Examples:
        >>> parse_kv_args(["host=localhost", "port=5432"])
        {'host': 'localhost', 'port': '5432'}

        >>> parse_kv_args(["key1=value with spaces", "key2=val2"])
        {'key1': 'value with spaces', 'key2': 'val2'}

        CLI integration with Click:

            >>> import click
            >>> @click.command()
            ... @click.option('--param', multiple=True)
            ... def my_command(param: tuple[str, ...]):
            ...     params = parse_kv_args(param)
            ...     print(params)
    """
    return _convert_param(args, InputFormat.KV_PAIRS, "args")


__all__ = [
    "InputFormat",
    "normalize_input",
    "parse_kv_args",
]
